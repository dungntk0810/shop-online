
package com.parkway.di.service.report;import com.parkway.common.response.company.CompanyResponseDTO;import com.parkway.di.constants.EntityEnum;import com.parkway.di.domain.DIClientDTO;import java.time.LocalDate;public interface HousingService {    void transformAndLoad(CompanyResponseDTO companyResponseDTO, Long historyId, String requestId, LocalDate defaultEffectiveDate);    void transformDependants(CompanyResponseDTO companyResponseDTO, Long historyId, String requestId);    void cleanData(EntityEnum entityEnum, DIClientDTO importMemberClientEnum);    void updateHistoryStatusEmployee(Long historyId, String requestId);    void updateHistoryStatusDependant(Long historyId, String requestId);}  

--------------------
import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.util.*;import java.util.stream.Collectors;import static com.parkway.common.constant.CommonConstants.MAX_IN_LIST_COUNT;import static com.parkway.common.constant.ValueInjectionConstant.HOUSING_DEPENDANT_STARTDATE;import static com.parkway.common.constant.ValueInjectionConstant.HOUSING_EMPLOYEE_STARTDATE;import static com.parkway.common.constant.di.DIConstant.DI_JOB;import static com.parkway.di.constants.CompanyConstants.CORPORATE_ID_PIRELLI;import static com.parkway.di.constants.ErrorMessageCode.*;import static com.parkway.di.constants.GEConstants.EXCEPTION;import static com.parkway.di.constants.GEConstants.SUCCESS_MSG;import static com.parkway.di.constants.ImportMemberConstants.*;import static com.parkway.di.constants.customAttributes.CustomAttributeConstants.*;@Service@RequiredArgsConstructor@Slf4jpublic class HousingServiceImpl implements HousingService, DIRequiredOverrideService {    @Value(HOUSING_EMPLOYEE_STARTDATE)    private LocalDate memberStartDate ;    @Value(HOUSING_DEPENDANT_STARTDATE)    private LocalDate dependantStartDate;    private final Common common;    private final HousingEmployeeRawDataRepository housingEmployeeRawDataRepository;    private final PlanSchemeApiIntegration planSchemeApiIntegration;    private final HousingDependantRawDataRepository housingDependantRawDataRepository;    private final HousingEmployeeFailureRepository housingEmployeeFailureRepository;    private final HousingEmployeeSuccessRepository housingEmployeeSuccessRepository;    private final HousingDependantFailureRepository housingDependantFailureRepository;    private final HousingDependantSuccessRepository housingDependantSuccessRepository;    private final HousingConfigVariableRepository housingConfigVariableRepository;    private final ImportHistoryRepository importHistoryRepository;    private final LogService logService;    private final NotificationApiIntegration notificationApiIntegration;    private final ImportDependantHelper importDependantHelper;    private final CompanyApiIntegration companyApiIntegration;    public void transformAndLoad(CompanyResponseDTO companyResponseDTO, Long historyId, String requestId, LocalDate defaultEffectiveDate) {        List<ImportMemberResponseDTO> importMemberResponseDTOList = transformEmployees(companyResponseDTO, requestId, defaultEffectiveDate);        if (!CollectionUtils.isEmpty(importMemberResponseDTOList)) {            List<ImportMemberResponseDTO> importSuccessMemberResponseDTOS = importMemberResponseDTOList                    .stream()                    .filter(ImportMemberResponseDTO::isSuccess)                    .collect(Collectors.toList());            importMemberResponseDTOList.removeAll(importSuccessMemberResponseDTOS);            housingEmployeeFailureRepository.saveAll(buildMemberFailures(importMemberResponseDTOList));            housingEmployeeSuccessRepository.saveAll(buildMemberSuccesses(importSuccessMemberResponseDTOS));        }        housingEmployeeRawDataRepository.deleteByRequestId(requestId);        updateHistoryStatusEmployee(historyId, requestId);        List<HousingEmployeeSuccess> employeeSuccesses = housingEmployeeSuccessRepository.findByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(requestId);        List<HousingEmployeeFailure> employeeFailures = housingEmployeeFailureRepository.findByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(requestId);        if (CollectionUtils.isEmpty(employeeSuccesses) && CollectionUtils.isEmpty(employeeFailures)) {            return;   

----------------------------------
    List<String> names = new ArrayList<>();    names.add(DIConstant.DI_RECIPIENTS);    List<HousingConfigVariable> configVariableList = housingConfigVariableRepository.findByNameIn(names);    HousingConfigVariable recipientsByCompany = housingConfigVariableRepository.findByNameIgnoreCase(companyResponseDTO.getCompanyNo().toString());    String recipients = configVariableList.stream().filter(x -> x.getName().equals(DIConstant.DI_RECIPIENTS)).findAny().orElseThrow(            () -> PWException.build().of(common.buildErrorMessage(ErrorMessageCode.RECIPIENTS_NOT_FOUND))    ).getValue();    if (recipientsByCompany != null) {        recipients = recipientsByCompany.getValue();    }    String subject = START_SUBJECT + companyResponseDTO.getCompanyName() + END_SUBJECT;    boolean isSent = sendLogEmailForEmployee(employeeSuccesses, employeeFailures, companyResponseDTO.getCompanyName(), IMP_SLASH + companyResponseDTO.getOhmCorporateId() + CharacterConstant.SLASH_LEFT, recipients, subject);    if (isSent) {        employeeSuccesses.forEach(x -> x.setSent(true));        employeeFailures.forEach(x -> x.setSent(true));        housingEmployeeFailureRepository.saveAll(employeeFailures);        housingEmployeeSuccessRepository.saveAll(employeeSuccesses);    }}private List<ImportMemberResponseDTO> transformEmployees(CompanyResponseDTO companyResponseDTO, String requestId, LocalDate defaultEffectiveDate) {    List<HousingEmployeeRawData> housingEmployeeRawDataList = housingEmployeeRawDataRepository.findByRequestId(requestId);    if (CollectionUtils.isEmpty(housingEmployeeRawDataList)) {        return Collections.emptyList();    }    List<ImportMemberResponseDTO> responses = new ArrayList<>();    if (companyResponseDTO == null) {        return new ArrayList<>();    }    Long companyNo = companyResponseDTO.getCompanyNo();    // Create/get custom attribute    List<CompanyCustomAttributeResponseDTO> companyCustomAttributeResponseDTOS = common.getCompanyCustomAttributes(companyNo);    List<PlanResponseDTO> planResponseDTOS = planSchemeApiIntegration.findPlansByCompanyNos(Sets.newHashSet(companyNo));    // Get overview    OverviewDTO overviewDTO = common.getMdmOverviewDTO(new HashSet<>());    Set<String> genders = common.collectSetNameAndSetCode(overviewDTO.getGenderNameValues(), overviewDTO.getGenderValues());    Set<String> maritalStatus = common.collectSetNameAndSetCode(overviewDTO.getMaritalStatusNameValues(), overviewDTO.getMaritalStatusValues());    List<ImportMemberResponseDTO> failureGenders = validateGenders(housingEmployeeRawDataList, genders);    housingEmployeeRawDataList.removeIf(housingEmployeeRawData -> common.isMemberIncludedInFailedResponses(failureGenders, housingEmployeeRawData.getRecordId()));    List<ImportMemberResponseDTO> failureMaritalStatus = validateMaritalStatus(housingEmployeeRawDataList, maritalStatus);    housingEmployeeRawDataList.removeIf(employeeRawData -> common.isMemberIncludedInFailedResponses(failureMaritalStatus, employeeRawData.getRecordId()));    responses.addAll(common.combineIntoOneCollection(failureGenders, failureMaritalStatus));    // 1 - process insert or update employees case use staffIDs    List<CompanyBenefitPeriodResponseDTO> benefitPeriodResponseDTOS = common.getAllCompanyBenefitPeriod(companyNo);    Set<String> staffIdList = housingEmployeeRawDataList.stream().map(HousingEmployeeRawData::getStaffId).filter(Objects::nonNull).collect(Collectors.toSet());    List<EmployeeResponseDTO> employeeResponseDTOListForStaffId = common.getEmployeesByStaffIdsAndStatusCodesNotIn(staffIdList, companyNo, Collections.singletonList(StatusCode.CANCELLED));    List<HousingEmployeeRawData> insertEmployees = new ArrayList<>();    List<HousingEmployeeRawData> updateEmployees = new ArrayList<>();    List<HousingEmployeeRawData> reinstateEmployees = new ArrayList<>();    filterRawDataList(housingEmployeeRawDataList, insertEmployees, updateEmployees, reinstateEmployees, companyResponseDTO, employeeResponseDTOListForStaffId, STAFF_ID);    // convert to importEmpRequestDTOS list for insert HousingEmployee process    List<ImportEmpRequestDTO> importEmpRequestDTOS = convertToImportEmpRequestDTO(insertEmployees, overviewDTO, companyCustomAttributeResponseDTOS, planResponseDTOS, companyResponseDTO, benefitPeriodResponseDTOS );    List<ImportEmpRequestDTO> updateEmpRequestDTOS = convertToImportEmpRequestDTOForUpdate(updateEmployees, employeeResponseDTOListForStaffId, overviewDTO, companyCustomAttributeResponseDTOS, planResponseDTOS , companyResponseDTO, STAFF_ID, benefitPeriodResponseDTOS, defaultEffectiveDate);    List<ImportEmpRequestDTO> reinstateEmpRequestDTOS = convertToImportEmpRequestDTOForUpdate(reinstateEmployees, employeeResponseDTOListForStaffId, overviewDTO, companyCustomAttributeResponseDTOS, planResponseDTOS, companyResponseDTO, STAFF_ID, benefitPeriodResponseDTOS, defaultEffectiveDate);    Set<String> icNoList = housingEmployeeRawDataList.stream().filter(x -> x.getStaffId() == null).map(HousingEmployeeRawData::getEmpNricNo).filter(Objects::nonNull).collect(Collectors.toSet());    List<EmployeeResponseDTO> employeeResponseDTOListFindByIcNo = common.getEmployee(icNoList, companyNo);    // 2 - process insert or update employees case use ICNo    insertEmployees = new ArrayList<>();    updateEmployees = new ArrayList<>();    reinstateEmployees = new ArrayList<>();    filterRawDataList(housingEmployeeRawDataList, insertEmployees, updateEmployees, reinstateEmployees, companyResponseDTO, employeeResponseDTOListFindByIcNo, IC_NO);    importEmpRequestDTOS.addAll(convertToImportEmpRequestDTO(insertEmployees, overviewDTO, companyCustomAttributeResponseDTOS, planResponseDTOS, companyResponseDTO, benefitPeriodResponseDTOS ));    updateEmpRequestDTOS.addAll(convertToImportEmpRequestDTOForUpdate(updateEmployees, employeeResponseDTOListFindByIcNo, overviewDTO, companyCustomAttributeResponseDTOS, planResponseDTOS,  companyResponseDTO, IC_NO, benefitPeriodResponseDTOS, defaultEffectiveDate));    reinstateEmpRequestDTOS.addAll(convertToImportEmpRequestDTOForUpdate(reinstateEmployees, employeeResponseDTOListFindByIcNo, overviewDTO, companyCustomAttributeResponseDTOS, planResponseDTOS, companyResponseDTO, IC_NO, benefitPeriodResponseDTOS, defaultEffectiveDate));    importEmpRequestDTOS.forEach(importEmpRequestDTO -> importEmpRequestDTO.setDiImportMemberAction(DIImportMemberAction.CREATE));    updateEmpRequestDTOS.forEach(updateEmpRequestDTO -> updateEmpRequestDTO.setDiImportMemberAction(DIImportMemberAction.UPDATE));    reinstateEmpRequestDTOS.forEach(reinstateEmpRequestDTO -> reinstateEmpRequestDTO.setDiImportMemberAction(DIImportMemberAction.REINSTATE));    List<ImportEmpRequestDTO> empRequestDTOS = new ArrayList<>();    empRequestDTOS.addAll(importEmpRequestDTOS);    empRequestDTOS.addAll(updateEmpRequestDTOS);    empRequestDTOS.addAll(reinstateEmpRequestDTOS);    if (!CollectionUtils.isEmpty(empRequestDTOS)) {        empRequestDTOS.sort(Comparator.comparing(ImportEmpRequestDTO::getLineNumber));        responses.addAll(common.submitMember(empRequestDTOS, MemberType.EMP.getValue()));    }    return responses;}@Overridepublic void transformDependants(CompanyResponseDTO companyResponseDTO, Long historyId, String requestId) {    List<ImportMemberResponseDTO> importMemberResponseDTOS = transformDependant(companyResponseDTO, requestId);    if (!CollectionUtils.isEmpty(importMemberResponseDTOS)) {        List<ImportMemberResponseDTO> importSuccessMemberResponseDTOS = importMemberResponseDTOS                .stream()                .filter(ImportMemberResponseDTO::isSuccess)                .collect(Collectors.toList());        importMemberResponseDTOS.removeAll(importSuccessMemberResponseDTOS);        housingDependantFailureRepository.saveAll(buildDependantFailures(importMemberResponseDTOS));        housingDependantSuccessRepository.saveAll(buildDependantSuccesses(importSuccessMemberResponseDTOS));    }    housingEmployeeRawDataRepository.deleteByRequestId(requestId);    updateHistoryStatusDependant(historyId, requestId);    List<HousingDependantSuccess> dependantSuccesses = housingDependantSuccessRepository.findByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(requestId);    List<HousingDependantFailure> dependantFailures = housingDependantFailureRepository.findByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(requestId);    if (CollectionUtils.isEmpty(dependantSuccesses) && CollectionUtils.isEmpty(dependantFailures)) {        return;    }    List<String> names = new ArrayList<>();    names.add(DIConstant.DI_RECIPIENTS);    names.add(DIConstant.PS_UNZIP_NAME);    List<HousingConfigVariable> configVariableList = housingConfigVariableRepository.findByNameIn(names);    HousingConfigVariable recipientsByCompany = housingConfigVariableRepository.findByNameIgnoreCase(companyResponseDTO.getCompanyNo().toString());    String recipients = configVariableList.stream().filter(x -> x.getName().equals(DIConstant.DI_RECIPIENTS)).findAny().orElseThrow(            () -> PWException.build().of(common.buildErrorMessage(ErrorMessageCode.RECIPIENTS_NOT_FOUND))    ).getValue();    if (recipientsByCompany != null) {        recipients = recipientsByCompany.getValue();    }    String subject = START_SUBJECT + companyResponseDTO.getCompanyName() + END_SUBJECT;    boolean isSent = sendLogEmailForDependant(dependantSuccesses, dependantFailures, companyResponseDTO.getCompanyName(), IMP_SLASH + companyResponseDTO.getOhmCorporateId() + CharacterConstant.SLASH_LEFT, recipients, subject);    if (isSent) {        dependantSuccesses.forEach(x -> x.setSent(true));        dependantFailures.forEach(x -> x.setSent(true));        housingDependantFailureRepository.saveAll(dependantFailures);        housingDependantSuccessRepository.saveAll(dependantSuccesses);    }} 
private List<ImportMemberResponseDTO> validateGenders(List<HousingEmployeeRawData> housingEmployeeRawData, Set<String> genders) {    List<ImportMemberResponseDTO> importMemberResponseDTOS = new ArrayList<>();    for (HousingEmployeeRawData item : housingEmployeeRawData) {        String gender = item.getGender();        if (StringUtils.isNotEmpty(gender)) {            Optional<String> optionalGender = genders.stream().filter(x -> x.trim().equalsIgnoreCase(gender)).findFirst();            if (!optionalGender.isPresent()) {                importMemberResponseDTOS.add(common.buildValidateFailMemberResponseDTO(item, common.buildErrorMessage(GENDER_NOT_FOUND, String.valueOf(item.getLineNumber()), gender)));            }        }    }    return importMemberResponseDTOS;}private List<ImportMemberResponseDTO> validateMaritalStatus(List<HousingEmployeeRawData> housingEmployeeRawData, Set<String> maritalStatusList) {    List<ImportMemberResponseDTO> importMemberResponseDTOList = new ArrayList<>();    for (HousingEmployeeRawData item : housingEmployeeRawData) {        String maritalStatus = item.getMaritalStatus();        if (StringUtils.isNotEmpty(maritalStatus)) {            Optional<String> optionalMaritalStatus = maritalStatusList.stream().filter(x -> x.trim().equalsIgnoreCase(maritalStatus)).findFirst();            if (!optionalMaritalStatus.isPresent()) {                importMemberResponseDTOList.add(common.buildValidateFailMemberResponseDTO(item, common.buildErrorMessage(MARITAL_STATUS_NOT_FOUND, String.valueOf(item.getLineNumber()), maritalStatus)));            }        }    }    return importMemberResponseDTOList;}private void filterRawDataList(List<HousingEmployeeRawData> rawDataList,                                                       List<HousingEmployeeRawData> insertHousingEmployeeRawData,                                                       List<HousingEmployeeRawData> updateHousingEmployeeRawData,                                                       List<HousingEmployeeRawData> reinstateHousingEmployeeRawData,                                                       CompanyResponseDTO companyResponseDTO,                                                       List<EmployeeResponseDTO> employeeResponseDTOS,                                                       String typeImport) {    Iterator<HousingEmployeeRawData> iterator = rawDataList.iterator();    while (iterator.hasNext()) {        HousingEmployeeRawData item = iterator.next();        Optional<EmployeeResponseDTO> employeeResponseDTOOptional = getEmployeeResponseDTOForDuplicatedKeyCase(employeeResponseDTOS, item, typeImport);        if (employeeResponseDTOOptional.isPresent()) {            LocalDateTime employeeResponseDTOTerminationDate = TimeZoneUtil.now().atTime(LocalTime.MIN);            if (employeeResponseDTOOptional.get().getTerminationDate() != null) {                employeeResponseDTOTerminationDate = employeeResponseDTOOptional.get().getTerminationDate().atTime(LocalTime.MIN);            }            long duration = Duration.between(employeeResponseDTOTerminationDate, memberStartDate).toDays();            if (duration > companyResponseDTO.getReinstatementEndDays()                    && StatusCode.TERMINATED.getValue().equalsIgnoreCase(employeeResponseDTOOptional.get().getStatusCode())) {                insertHousingEmployeeRawData.add(item);                iterator.remove();                continue;            }            if (duration <= companyResponseDTO.getReinstatementEndDays()                    && employeeResponseDTOOptional.get().getTerminationDate() != null                    && StatusCode.TERMINATED.getValue().equalsIgnoreCase(employeeResponseDTOOptional.get().getStatusCode())                    && companyResponseDTO.getReinstatementEndDays() > 0) {                reinstateHousingEmployeeRawData.add(item);                iterator.remove();                continue;            }            updateHousingEmployeeRawData.add(item);        } else {            insertHousingEmployeeRawData.add(item);        }    }}private Optional<EmployeeResponseDTO> getEmployeeResponseDTOForDuplicatedKeyCase(List<EmployeeResponseDTO> employeeResponseDTOList, HousingEmployeeRawData housingEmployeeRawData, String typeTransform) {    List<EmployeeResponseDTO> employeeResponseDTOS;    log.info("[getEmployeeResponseDTOForDuplicatedKeyCase] staffId: {}, icNo: {}, typeTransform: {}",            housingEmployeeRawData.getStaffId(), housingEmployeeRawData.getEmpNricNo(), typeTransform);    if (STAFF_ID.equals(typeTransform)) {        employeeResponseDTOS = employeeResponseDTOList.stream().filter(x -> housingEmployeeRawData.getStaffId().equalsIgnoreCase(x.getStaffId())).collect(Collectors.toList());    } else {        employeeResponseDTOS = employeeResponseDTOList.stream().filter(x -> housingEmployeeRawData.getEmpNricNo().equalsIgnoreCase(x.getIcNo())).collect(Collectors.toList());    }    if (employeeResponseDTOS.size() > 1) {        Collections.sort(employeeResponseDTOS, (e1, e2) -> e2.getEmployeeCode().compareTo(e1.getEmployeeCode()));        EmployeeResponseDTO responseDTO = employeeResponseDTOS.get(0);        return employeeResponseDTOS.stream()                .filter(employeeResponseDTO -> employeeResponseDTO.getEmployeeCode().equalsIgnoreCase(responseDTO.getEmployeeCode()))                .findAny();    }    return getEmployeeResponseDTO(employeeResponseDTOList, housingEmployeeRawData, typeTransform);}private Optional<EmployeeResponseDTO> getEmployeeResponseDTO(List<EmployeeResponseDTO> employeeResponseDTOList, HousingEmployeeRawData housingEmployeeRawData, String typeTransform) {    Optional<EmployeeResponseDTO> employeeResponseDTO;    if (STAFF_ID.equals(typeTransform)) {        employeeResponseDTO = employeeResponseDTOList.stream().filter(x -> housingEmployeeRawData.getStaffId().equalsIgnoreCase(x.getStaffId())).findAny();    } else {        employeeResponseDTO = employeeResponseDTOList.stream().filter(x -> housingEmployeeRawData.getEmpNricNo().equalsIgnoreCase(x.getIcNo())).findAny();    }    return employeeResponseDTO;}private List<ImportEmpRequestDTO> convertToImportEmpRequestDTOForUpdate(List<HousingEmployeeRawData> housingEmployeeRawData,                                                                        List<EmployeeResponseDTO> employeeResponseDTOS,                                                                        OverviewDTO overviewDTO,                                                                        List<CompanyCustomAttributeResponseDTO> companyCustomAttributeResponseDTOList,                                                                        List<PlanResponseDTO> planResponseDTOS,                                                                        CompanyResponseDTO companyResponseDTO, String typeImport,                                                                        List<CompanyBenefitPeriodResponseDTO> benefitPeriodResponseDTOS, LocalDate defaultEffectiveDate) {    List<ImportEmpRequestDTO> empRequestDTOS = new ArrayList<>();    housingEmployeeRawData.forEach(item -> {        List<PlanResponseDTO> planResponseDTOList = Collections.EMPTY_LIST;        log.info("[convertToImportEmpRequestDTOForUpdate] planResponseDTOList = {}", planResponseDTOList);        Optional<EmployeeResponseDTO> employeeResponseDTOOptional = getEmployeeResponseDTOForDuplicatedKeyCase(employeeResponseDTOS, item, typeImport);        if (employeeResponseDTOOptional.isPresent()) {            EmployeeResponseDTO employeeResponseDTO = employeeResponseDTOOptional.get();            EmployeeRequestDTO employeeRequestDTO = common.convertEmployeeRequestDTO(employeeResponseDTO);            LocalDate employmentDate = employeeResponseDTO.getEmploymentStartDate();            ImportEmpRequestDTO importEmpRequestDTO = ImportEmpRequestDTO.builder()                            .statusRequestDTO(StatusRequestDTO.builder()                            .terminationDate(item.getTerminationDate())                            .build())                    .overviewInfo(updateEmployeeRequestDTO(item, overviewDTO, companyResponseDTO.getCompanyNo(), employeeRequestDTO))                    .attributes(EmployeeAttributeEnrollmentRequestDTO.builder()                            .employeeCustomAttributeDTOs(buildEmployeeCustomAttribute(item, companyCustomAttributeResponseDTOList, buildCustomAttributeEffectiveDateForEmployee(defaultEffectiveDate, employmentDate)))                            .build())                    .build();            importEmpRequestDTO.setPlanSchemeLst(common.buildMemberPlanRequestDTO(planResponseDTOS, memberStartDate, benefitPeriodResponseDTOS));            importEmpRequestDTO.setRecordId(item.getRecordId());            importEmpRequestDTO.setLineNumber(item.getLineNumber());            importEmpRequestDTO.getOverviewInfo().setEmployeeNo(employeeResponseDTO.getEmployeeNo());            importEmpRequestDTO.setReinstatementDate(memberStartDate);            importEmpRequestDTO.getOverviewInfo().setContractorFlag(employeeResponseDTO.isContractorFlag());            log.info("[convertToImportEmpRequestDTOForUpdate] recordID = {}, employee custom attribute = {}, member plan = {}", importEmpRequestDTO.getRecordId(), JsonUtils.toJsonStringNoThrow(importEmpRequestDTO.getAttributes().getEmployeeCustomAttributeDTOs()), JsonUtils.toJsonStringNoThrow(importEmpRequestDTO.getPlanSchemeLst()));            empRequestDTOS.add(importEmpRequestDTO);        }    });    return empRequestDTOS;} 
private List<ImportEmpRequestDTO> convertToImportEmpRequestDTO(List<HousingEmployeeRawData> housingEmployeeRawData, OverviewDTO overviewDTO,                                                               List<CompanyCustomAttributeResponseDTO> companyCustomAttributeResponseDTOList,                                                               List<PlanResponseDTO> planResponseDTOS, CompanyResponseDTO companyResponseDTO,                                                               List<CompanyBenefitPeriodResponseDTO> benefitPeriodResponseDTOS) {    List<ImportEmpRequestDTO> empRequestDTOS = new ArrayList<>();    housingEmployeeRawData.forEach(item -> {        ImportEmpRequestDTO importEmpRequestDTO = ImportEmpRequestDTO.builder()                                    .overviewInfo(buildEmployeeRequestDTO(item, overviewDTO, companyResponseDTO.getCompanyNo()))                .statusRequestDTO(StatusRequestDTO.builder()                        .terminationDate(item.getTerminationDate())                        .build())                .attributes(EmployeeAttributeEnrollmentRequestDTO.builder()                        .employeeCustomAttributeDTOs(buildEmployeeCustomAttribute(item, companyCustomAttributeResponseDTOList, memberStartDate))                        .build())                .diClient(DIClient.IMP_HOUSING)                .build();        importEmpRequestDTO.setPlanSchemeLst(common.buildMemberPlanRequestDTO(planResponseDTOS, memberStartDate, benefitPeriodResponseDTOS));        importEmpRequestDTO.setRecordId(item.getRecordId());        importEmpRequestDTO.setLineNumber(item.getLineNumber());        log.info("[convertToImportEmpRequestDTO] recordID = {}, employee custom attribute = {}, member plan = {}", importEmpRequestDTO.getRecordId(), JsonUtils.toJsonStringNoThrow(importEmpRequestDTO.getAttributes().getEmployeeCustomAttributeDTOs()), JsonUtils.toJsonStringNoThrow(importEmpRequestDTO.getPlanSchemeLst()));        empRequestDTOS.add(importEmpRequestDTO);    });    return empRequestDTOS;}private List<EmployeeCustomAttributeRequestDTO> buildEmployeeCustomAttribute(HousingEmployeeRawData item, List<CompanyCustomAttributeResponseDTO> companyCustomAttributeResponseDTOS, LocalDate startDate) {    List<EmployeeCustomAttributeRequestDTO> employeeCustomAttributeRequestDTOs = new ArrayList<>();    for (CompanyCustomAttributeResponseDTO c : companyCustomAttributeResponseDTOS) {        employeeCustomAttributeRequestDTOs.add(filterEmployeeCustomAttribute(c, item, startDate));    }    employeeCustomAttributeRequestDTOs.removeIf(p -> p.getCustomAttributeValueNo() == null && p.getCustomAttributeValueStr() == null);    return employeeCustomAttributeRequestDTOs.stream().filter(x -> x.getCustomAttributeNo() != null).collect(Collectors.toList());}private LocalDate buildCustomAttributeEffectiveDateForEmployee(LocalDate defaultEffectiveDate, LocalDate employmentDate) {    LocalDate effectiveDate = defaultEffectiveDate;    if (LocalDate.now().isBefore(employmentDate)) {        effectiveDate = employmentDate;    }    return effectiveDate;}private EmployeeCustomAttributeRequestDTO filterEmployeeCustomAttribute(CompanyCustomAttributeResponseDTO c, HousingEmployeeRawData item, LocalDate startDate) {    EmployeeCustomAttributeRequestDTO employeeCustomAttributeRequestDTO = new EmployeeCustomAttributeRequestDTO();    Map<String, String> customAttributeMaps = getCustomAttributesMap(item);    String customAttributeStr = customAttributeMaps.get(c.getCustomAttributeStr().toUpperCase());    employeeCustomAttributeRequestDTO.setCustomAttributeNo(c.getCustomAttributeNo());    employeeCustomAttributeRequestDTO.setEffectiveDate(startDate);    if (CollectionUtils.isNotEmpty(c.getCustomAttributeValueResponseDTOList())) {        for (CompanyCustomAttributeValueResponseDTO x : c.getCustomAttributeValueResponseDTOList()) {            if (customAttributeStr != null && (customAttributeStr.equalsIgnoreCase(x.getCustomAttributeValueName()) || customAttributeStr.equalsIgnoreCase(x.getCustomAttributeValueCode()) || customAttributeStr.equalsIgnoreCase(x.getCustomAttributeValueExternalId()))) {                employeeCustomAttributeRequestDTO.setCustomAttributeValueNo(x.getCustomAttributeValueNo());                break;            }        }    }    if (customAttributeStr != null && employeeCustomAttributeRequestDTO.getCustomAttributeValueNo() == null) {            employeeCustomAttributeRequestDTO.setCustomAttributeValueStr(customAttributeStr);            employeeCustomAttributeRequestDTO.setCustomAttributeValueCode(customAttributeStr);            employeeCustomAttributeRequestDTO.setCustomAttributeValueExternalId(customAttributeStr);    }    return employeeCustomAttributeRequestDTO;}private Map<String, String> getCustomAttributesMap(HousingEmployeeRawData item) {    Map<String, String> customAttributeMaps = new HashMap<>();    customAttributeMaps.put(SCHEME.toUpperCase(), item.getCurrentMedicalScheme());    customAttributeMaps.put(GROUP.toUpperCase(), item.getGroup());    return customAttributeMaps;}private EmployeeRequestDTO buildEmployeeRequestDTO(HousingEmployeeRawData item, OverviewDTO mdmOverviewDTO, Long companyNo) {    EmployeeRequestDTO employeeRequestDto = new EmployeeRequestDTO();    buildImportEmployeeRequestDTO(item, mdmOverviewDTO, companyNo, employeeRequestDto);    return employeeRequestDto;} 
private void buildImportEmployeeRequestDTO(HousingEmployeeRawData item, OverviewDTO mdmOverviewDTO, Long companyNo, EmployeeRequestDTO employeeRequestDto) {    if (StringUtils.isNotEmpty(item.getStaffId())) {        employeeRequestDto.setStaffId(item.getStaffId());    }    if (StringUtils.isNotEmpty(item.getEmpNricNo())) {        employeeRequestDto.setIcNo(item.getEmpNricNo());    }    String maritalStatus = item.getMaritalStatus();    if (StringUtils.isNotEmpty(maritalStatus)) {        employeeRequestDto.setMaritalStatusNo(getValueFromTwoMaps(mdmOverviewDTO.getMaritalStatusNameValues(), mdmOverviewDTO.getMaritalStatusValues(), maritalStatus));    }    if (memberStartDate != null) {        employeeRequestDto.setEmploymentStartDate(memberStartDate);        employeeRequestDto.setCoverageStartDate(memberStartDate);    }    String gender = item.getGender();    if (StringUtils.isNotEmpty(gender)) {        employeeRequestDto.setGenderNo(getValueFromTwoMaps(mdmOverviewDTO.getGenderValues(), mdmOverviewDTO.getGenderNameValues(), gender));    }    String name = item.getName();    if (StringUtils.isNotEmpty(name)) {        employeeRequestDto.setEmployeeName(name);    }    LocalDate dob = item.getDob();    if (dob != null) {        employeeRequestDto.setDob(dob);    }    if (StringUtils.isNotEmpty(item.getEmailAdress())) {        employeeRequestDto.setEmail(item.getEmailAdress());    }}private Long getValueFromTwoMaps(Map<String, Long> map1, Map<String, Long> map2, String value) {    Long aLong = map1.get(value.toUpperCase());    if (aLong == null) {        aLong = map2.get(value.toUpperCase());    }    return aLong;}private EmployeeRequestDTO updateEmployeeRequestDTO(HousingEmployeeRawData item, OverviewDTO mdmOverviewDTO, Long companyNo, EmployeeRequestDTO employeeRequestDTO) {    buildImportEmployeeRequestDTO(item, mdmOverviewDTO, companyNo, employeeRequestDTO);    return employeeRequestDTO;}private List<ImportMemberResponseDTO> transformDependant(CompanyResponseDTO companyResponseDTO, String requestId) {    List<HousingDependantRawData> housingDependantRawDataList = housingDependantRawDataRepository.findByRequestId(requestId);    if (CollectionUtils.isEmpty(housingDependantRawDataList)) {        return Collections.emptyList();    }    Set<String> externalIdOfDEP = housingDependantRawDataList.stream()            .map(HousingDependantRawData::getStaffId)            .filter(Objects::nonNull)            .collect(Collectors.toSet());    List<ImportMemberResponseDTO> responses = new ArrayList<>();    Long companyNo = companyResponseDTO.getCompanyNo();    List<DependantResponseDTO> existingDependantResponseDTOs = common.getDependantsByExternalId(externalIdOfDEP, companyResponseDTO.getCompanyNo());    List<Long> dependantNos = existingDependantResponseDTOs.stream().map(DependantResponseDTO::getDependantNo).filter(Objects::nonNull).collect(Collectors.toList());    List<DependantCustomAttributeResponseDTO> dependantCustomAttributesByDependantNos = common.getDependantCustomAttributesByDependantNos(dependantNos);    List<DependantCustomAttributeResponseDTO> dependantCustomAttributeResponseDTOS = importDependantHelper.filterDependantCustomAttrByEffectedDate(dependantCustomAttributesByDependantNos);    // Create/get custom attribute    List<CompanyCustomAttributeResponseDTO> companyCustomAttributeResponseDTOS = common.getCompanyCustomAttributes(companyNo);    // Get overview    OverviewDTO overviewDTO = common.getMdmOverviewDTO(new HashSet<>());    Set<String> genders = common.collectSetNameAndSetCode(overviewDTO.getGenderNameValues(), overviewDTO.getGenderValues());    Set<String> relationships = common.collectSetNameAndSetCode(overviewDTO.getRelationshipCodeValues(),overviewDTO.getRelationShipValues());    List<ImportMemberResponseDTO> failureGenders = validateDependantGenders(housingDependantRawDataList, genders);    housingDependantRawDataList.removeIf(item -> common.isMemberIncludedInFailedResponses(failureGenders, item.getRecordId()));    List<ImportMemberResponseDTO> failureRelationships = validateDependantRelationships(housingDependantRawDataList, relationships);    housingDependantRawDataList.removeIf(item -> common.isMemberIncludedInFailedResponses(failureRelationships, item.getRecordId()));    // Collect employee staff ids    Set<String> employeeStaffIds = housingDependantRawDataList.stream().map(HousingDependantRawData::getStaffId).filter(Objects::nonNull).collect(Collectors.toSet());    List<EmployeeResponseDTO> employeeResponseDTOSByStaffId = common.getEmployeesByStaffIdsAndStatusCodesNotIn(employeeStaffIds, companyNo, Arrays.asList(StatusCode.CANCELLED));    // Collect employee icNos    Set<String> employeeIcNos = housingDependantRawDataList.stream().filter(x -> x.getStaffId() == null).map(HousingDependantRawData::getEmpNric).filter(Objects::nonNull).collect(Collectors.toSet());    List<EmployeeResponseDTO> employeeResponseDTOSByIcNos = common.getEmployee(employeeIcNos, companyNo);    // if any dependant has employee that does not exists in o2 -> remove    List<ImportMemberResponseDTO> failureEmployee = validateEmployees(employeeResponseDTOSByIcNos,employeeResponseDTOSByStaffId, housingDependantRawDataList);    housingDependantRawDataList.removeIf(item -> common.isMemberIncludedInFailedResponses(failureEmployee, item.getRecordId()));    responses.addAll(common.combineIntoOneCollection(failureGenders, failureRelationships, failureEmployee));    // 1 - process insert or update dependants case use ICNo    Map<Integer, String> rawDataRecordIdsAndIcNos = housingDependantRawDataList            .stream()            .collect(Collectors.toMap(HousingDependantRawData::getRecordId, HousingDependantRawData::getEmpNric));    List<DependantResponseDTO> findDependantResponseDTOSByIcNo = new ArrayList<>();    Map<ActionTypeEnum, List<HousingDependantRawData>> insertAndUpdateRawDataMap = common.splitRawDataIntoInsertAndUpdateList(housingDependantRawDataList, rawDataRecordIdsAndIcNos, Collections.emptyList(), findDependantResponseDTOSByIcNo, IC_NO, Boolean.FALSE);    List<HousingDependantRawData> insertDependants = new ArrayList<>();    insertDependants.addAll(insertAndUpdateRawDataMap.get(ActionTypeEnum.INSERT));    List<HousingDependantRawData> updateDependants = insertAndUpdateRawDataMap.get(ActionTypeEnum.UPDATE);    filterReinstateDependantRawData(updateDependants, insertDependants, findDependantResponseDTOSByIcNo);    List<ImportMemberResponseDTO> failedDuplicateEmployee2 = validateDuplicateAssignEmpForDep(insertDependants, employeeResponseDTOSByStaffId, employeeResponseDTOSByIcNos, findDependantResponseDTOSByIcNo);    insertDependants.removeIf(dependant -> common.isMemberIncludedInFailedResponses(failedDuplicateEmployee2, dependant.getRecordId()));    List<ImportMemberResponseDTO> validateUpdateRelationshipUpdate2 = filterInvalidDependantForUpdateAction(insertDependants, findDependantResponseDTOSByIcNo, overviewDTO);    insertDependants.removeIf(item -> common.isMemberIncludedInFailedResponses(validateUpdateRelationshipUpdate2, item.getRecordId()));    List<ImportMemberResponseDTO> failedDuplicateEmployee3 = validateDuplicateAssignEmpForDep(updateDependants, employeeResponseDTOSByStaffId, employeeResponseDTOSByIcNos, findDependantResponseDTOSByIcNo);    updateDependants.removeIf(dependant -> common.isMemberIncludedInFailedResponses(failedDuplicateEmployee3, dependant.getRecordId()));    List<ImportMemberResponseDTO> validateUpdateRelationshipUpdate3 = filterInvalidDependantForUpdateAction(updateDependants, findDependantResponseDTOSByIcNo, overviewDTO);    updateDependants.removeIf(item -> common.isMemberIncludedInFailedResponses(validateUpdateRelationshipUpdate3, item.getRecordId()));    List<ImportDepRequestDTO> importDepRequestDTOS = convertToImportDeptRequestDTO(insertDependants, overviewDTO, companyNo, employeeResponseDTOSByIcNos, employeeResponseDTOSByStaffId, companyCustomAttributeResponseDTOS);    List<ImportDepRequestDTO> updateDeptRequestDTOList = convertToImportDepRequestDTOForUpdate(updateDependants, overviewDTO, employeeResponseDTOSByIcNos,employeeResponseDTOSByStaffId, findDependantResponseDTOSByIcNo, companyNo,companyCustomAttributeResponseDTOS,dependantCustomAttributeResponseDTOS);    importDepRequestDTOS.forEach(importDepRequestDTO -> importDepRequestDTO.setDiImportMemberAction(DIImportMemberAction.CREATE));    updateDeptRequestDTOList.forEach(updateDepRequestDTO -> updateDepRequestDTO.setDiImportMemberAction(DIImportMemberAction.UPDATE));    List<ImportDepRequestDTO> depRequestDTOS = new ArrayList<>();    depRequestDTOS.addAll(importDepRequestDTOS);    depRequestDTOS.addAll(updateDeptRequestDTOList);    if (!CollectionUtils.isEmpty(depRequestDTOS)) {        depRequestDTOS.sort(Comparator.comparing(ImportDepRequestDTO::getLineNumber));        responses.addAll(common.submitMember(depRequestDTOS, MemberType.DEP.getValue()));    }    return responses;} 
private List<ImportMemberResponseDTO> validateGenders(List<HousingEmployeeRawData> housingEmployeeRawData, Set<String> genders) {    List<ImportMemberResponseDTO> importMemberResponseDTOS = new ArrayList<>();    for (HousingEmployeeRawData item : housingEmployeeRawData) {        String gender = item.getGender();        if (StringUtils.isNotEmpty(gender)) {            Optional<String> optionalGender = genders.stream().filter(x -> x.trim().equalsIgnoreCase(gender)).findFirst();            if (!optionalGender.isPresent()) {                importMemberResponseDTOS.add(common.buildValidateFailMemberResponseDTO(item, common.buildErrorMessage(GENDER_NOT_FOUND, String.valueOf(item.getLineNumber()), gender)));            }        }    }    return importMemberResponseDTOS;}private List<ImportMemberResponseDTO> validateMaritalStatus(List<HousingEmployeeRawData> housingEmployeeRawData, Set<String> maritalStatusList) {    List<ImportMemberResponseDTO> importMemberResponseDTOList = new ArrayList<>();    for (HousingEmployeeRawData item : housingEmployeeRawData) {        String maritalStatus = item.getMaritalStatus();        if (StringUtils.isNotEmpty(maritalStatus)) {            Optional<String> optionalMaritalStatus = maritalStatusList.stream().filter(x -> x.trim().equalsIgnoreCase(maritalStatus)).findFirst();            if (!optionalMaritalStatus.isPresent()) {                importMemberResponseDTOList.add(common.buildValidateFailMemberResponseDTO(item, common.buildErrorMessage(MARITAL_STATUS_NOT_FOUND, String.valueOf(item.getLineNumber()), maritalStatus)));            }        }    }    return importMemberResponseDTOList;}private void filterRawDataList(List<HousingEmployeeRawData> rawDataList,                                                       List<HousingEmployeeRawData> insertHousingEmployeeRawData,                                                       List<HousingEmployeeRawData> updateHousingEmployeeRawData,                                                       List<HousingEmployeeRawData> reinstateHousingEmployeeRawData,                                                       CompanyResponseDTO companyResponseDTO,                                                       List<EmployeeResponseDTO> employeeResponseDTOS,                                                       String typeImport) {    Iterator<HousingEmployeeRawData> iterator = rawDataList.iterator();    while (iterator.hasNext()) {        HousingEmployeeRawData item = iterator.next();        Optional<EmployeeResponseDTO> employeeResponseDTOOptional = getEmployeeResponseDTOForDuplicatedKeyCase(employeeResponseDTOS, item, typeImport);        if (employeeResponseDTOOptional.isPresent()) {            LocalDateTime employeeResponseDTOTerminationDate = TimeZoneUtil.now().atTime(LocalTime.MIN);            if (employeeResponseDTOOptional.get().getTerminationDate() != null) {                employeeResponseDTOTerminationDate = employeeResponseDTOOptional.get().getTerminationDate().atTime(LocalTime.MIN);            }            long duration = Duration.between(employeeResponseDTOTerminationDate, memberStartDate).toDays();            if (duration > companyResponseDTO.getReinstatementEndDays()                    && StatusCode.TERMINATED.getValue().equalsIgnoreCase(employeeResponseDTOOptional.get().getStatusCode())) {                insertHousingEmployeeRawData.add(item);                iterator.remove();                continue;            }            if (duration <= companyResponseDTO.getReinstatementEndDays()                    && employeeResponseDTOOptional.get().getTerminationDate() != null                    && StatusCode.TERMINATED.getValue().equalsIgnoreCase(employeeResponseDTOOptional.get().getStatusCode())                    && companyResponseDTO.getReinstatementEndDays() > 0) {                reinstateHousingEmployeeRawData.add(item);                iterator.remove();                continue;            }            updateHousingEmployeeRawData.add(item);        } else {            insertHousingEmployeeRawData.add(item);        }    }}private Optional<EmployeeResponseDTO> getEmployeeResponseDTOForDuplicatedKeyCase(List<EmployeeResponseDTO> employeeResponseDTOList, HousingEmployeeRawData housingEmployeeRawData, String typeTransform) {    List<EmployeeResponseDTO> employeeResponseDTOS;    log.info("[getEmployeeResponseDTOForDuplicatedKeyCase] staffId: {}, icNo: {}, typeTransform: {}",            housingEmployeeRawData.getStaffId(), housingEmployeeRawData.getEmpNricNo(), typeTransform);    if (STAFF_ID.equals(typeTransform)) {        employeeResponseDTOS = employeeResponseDTOList.stream().filter(x -> housingEmployeeRawData.getStaffId().equalsIgnoreCase(x.getStaffId())).collect(Collectors.toList());    } else {        employeeResponseDTOS = employeeResponseDTOList.stream().filter(x -> housingEmployeeRawData.getEmpNricNo().equalsIgnoreCase(x.getIcNo())).collect(Collectors.toList());    }    if (employeeResponseDTOS.size() > 1) {        Collections.sort(employeeResponseDTOS, (e1, e2) -> e2.getEmployeeCode().compareTo(e1.getEmployeeCode()));        EmployeeResponseDTO responseDTO = employeeResponseDTOS.get(0);        return employeeResponseDTOS.stream()                .filter(employeeResponseDTO -> employeeResponseDTO.getEmployeeCode().equalsIgnoreCase(responseDTO.getEmployeeCode()))                .findAny();    }    return getEmployeeResponseDTO(employeeResponseDTOList, housingEmployeeRawData, typeTransform);}private Optional<EmployeeResponseDTO> getEmployeeResponseDTO(List<EmployeeResponseDTO> employeeResponseDTOList, HousingEmployeeRawData housingEmployeeRawData, String typeTransform) {    Optional<EmployeeResponseDTO> employeeResponseDTO;    if (STAFF_ID.equals(typeTransform)) {        employeeResponseDTO = employeeResponseDTOList.stream().filter(x -> housingEmployeeRawData.getStaffId().equalsIgnoreCase(x.getStaffId())).findAny();    } else {        employeeResponseDTO = employeeResponseDTOList.stream().filter(x -> housingEmployeeRawData.getEmpNricNo().equalsIgnoreCase(x.getIcNo())).findAny();    }    return employeeResponseDTO;}private List<ImportEmpRequestDTO> convertToImportEmpRequestDTOForUpdate(List<HousingEmployeeRawData> housingEmployeeRawData,                                                                        List<EmployeeResponseDTO> employeeResponseDTOS,                                                                        OverviewDTO overviewDTO,                                                                        List<CompanyCustomAttributeResponseDTO> companyCustomAttributeResponseDTOList,                                                                        List<PlanResponseDTO> planResponseDTOS,                                                                        CompanyResponseDTO companyResponseDTO, String typeImport,                                                                        List<CompanyBenefitPeriodResponseDTO> benefitPeriodResponseDTOS, LocalDate defaultEffectiveDate) {    List<ImportEmpRequestDTO> empRequestDTOS = new ArrayList<>();    housingEmployeeRawData.forEach(item -> {        List<PlanResponseDTO> planResponseDTOList = Collections.EMPTY_LIST;        log.info("[convertToImportEmpRequestDTOForUpdate] planResponseDTOList = {}", planResponseDTOList);        Optional<EmployeeResponseDTO> employeeResponseDTOOptional = getEmployeeResponseDTOForDuplicatedKeyCase(employeeResponseDTOS, item, typeImport);        if (employeeResponseDTOOptional.isPresent()) {            EmployeeResponseDTO employeeResponseDTO = employeeResponseDTOOptional.get();            EmployeeRequestDTO employeeRequestDTO = common.convertEmployeeRequestDTO(employeeResponseDTO);            LocalDate employmentDate = employeeResponseDTO.getEmploymentStartDate();            ImportEmpRequestDTO importEmpRequestDTO = ImportEmpRequestDTO.builder()                            .statusRequestDTO(StatusRequestDTO.builder()                            .terminationDate(item.getTerminationDate())                            .build())                    .overviewInfo(updateEmployeeRequestDTO(item, overviewDTO, companyResponseDTO.getCompanyNo(), employeeRequestDTO))                    .attributes(EmployeeAttributeEnrollmentRequestDTO.builder()                            .employeeCustomAttributeDTOs(buildEmployeeCustomAttribute(item, companyCustomAttributeResponseDTOList, buildCustomAttributeEffectiveDateForEmployee(defaultEffectiveDate, employmentDate)))                            .build())                    .build();            importEmpRequestDTO.setPlanSchemeLst(common.buildMemberPlanRequestDTO(planResponseDTOS, memberStartDate, benefitPeriodResponseDTOS));            importEmpRequestDTO.setRecordId(item.getRecordId());            importEmpRequestDTO.setLineNumber(item.getLineNumber());            importEmpRequestDTO.getOverviewInfo().setEmployeeNo(employeeResponseDTO.getEmployeeNo());            importEmpRequestDTO.setReinstatementDate(memberStartDate);            importEmpRequestDTO.getOverviewInfo().setContractorFlag(employeeResponseDTO.isContractorFlag());            log.info("[convertToImportEmpRequestDTOForUpdate] recordID = {}, employee custom attribute = {}, member plan = {}", importEmpRequestDTO.getRecordId(), JsonUtils.toJsonStringNoThrow(importEmpRequestDTO.getAttributes().getEmployeeCustomAttributeDTOs()), JsonUtils.toJsonStringNoThrow(importEmpRequestDTO.getPlanSchemeLst()));            empRequestDTOS.add(importEmpRequestDTO);        }    });    return empRequestDTOS;} 
private List<ImportEmpRequestDTO> convertToImportEmpRequestDTO(List<HousingEmployeeRawData> housingEmployeeRawData, OverviewDTO overviewDTO,                                                               List<CompanyCustomAttributeResponseDTO> companyCustomAttributeResponseDTOList,                                                               List<PlanResponseDTO> planResponseDTOS, CompanyResponseDTO companyResponseDTO,                                                               List<CompanyBenefitPeriodResponseDTO> benefitPeriodResponseDTOS) {    List<ImportEmpRequestDTO> empRequestDTOS = new ArrayList<>();    housingEmployeeRawData.forEach(item -> {        ImportEmpRequestDTO importEmpRequestDTO = ImportEmpRequestDTO.builder()                                    .overviewInfo(buildEmployeeRequestDTO(item, overviewDTO, companyResponseDTO.getCompanyNo()))                .statusRequestDTO(StatusRequestDTO.builder()                        .terminationDate(item.getTerminationDate())                        .build())                .attributes(EmployeeAttributeEnrollmentRequestDTO.builder()                        .employeeCustomAttributeDTOs(buildEmployeeCustomAttribute(item, companyCustomAttributeResponseDTOList, memberStartDate))                        .build())                .diClient(DIClient.IMP_HOUSING)                .build();        importEmpRequestDTO.setPlanSchemeLst(common.buildMemberPlanRequestDTO(planResponseDTOS, memberStartDate, benefitPeriodResponseDTOS));        importEmpRequestDTO.setRecordId(item.getRecordId());        importEmpRequestDTO.setLineNumber(item.getLineNumber());        log.info("[convertToImportEmpRequestDTO] recordID = {}, employee custom attribute = {}, member plan = {}", importEmpRequestDTO.getRecordId(), JsonUtils.toJsonStringNoThrow(importEmpRequestDTO.getAttributes().getEmployeeCustomAttributeDTOs()), JsonUtils.toJsonStringNoThrow(importEmpRequestDTO.getPlanSchemeLst()));        empRequestDTOS.add(importEmpRequestDTO);    });    return empRequestDTOS;}private List<EmployeeCustomAttributeRequestDTO> buildEmployeeCustomAttribute(HousingEmployeeRawData item, List<CompanyCustomAttributeResponseDTO> companyCustomAttributeResponseDTOS, LocalDate startDate) {    List<EmployeeCustomAttributeRequestDTO> employeeCustomAttributeRequestDTOs = new ArrayList<>();    for (CompanyCustomAttributeResponseDTO c : companyCustomAttributeResponseDTOS) {        employeeCustomAttributeRequestDTOs.add(filterEmployeeCustomAttribute(c, item, startDate));    }    employeeCustomAttributeRequestDTOs.removeIf(p -> p.getCustomAttributeValueNo() == null && p.getCustomAttributeValueStr() == null);    return employeeCustomAttributeRequestDTOs.stream().filter(x -> x.getCustomAttributeNo() != null).collect(Collectors.toList());}private LocalDate buildCustomAttributeEffectiveDateForEmployee(LocalDate defaultEffectiveDate, LocalDate employmentDate) {    LocalDate effectiveDate = defaultEffectiveDate;    if (LocalDate.now().isBefore(employmentDate)) {        effectiveDate = employmentDate;    }    return effectiveDate;}private EmployeeCustomAttributeRequestDTO filterEmployeeCustomAttribute(CompanyCustomAttributeResponseDTO c, HousingEmployeeRawData item, LocalDate startDate) {    EmployeeCustomAttributeRequestDTO employeeCustomAttributeRequestDTO = new EmployeeCustomAttributeRequestDTO();    Map<String, String> customAttributeMaps = getCustomAttributesMap(item);    String customAttributeStr = customAttributeMaps.get(c.getCustomAttributeStr().toUpperCase());    employeeCustomAttributeRequestDTO.setCustomAttributeNo(c.getCustomAttributeNo());    employeeCustomAttributeRequestDTO.setEffectiveDate(startDate);    if (CollectionUtils.isNotEmpty(c.getCustomAttributeValueResponseDTOList())) {        for (CompanyCustomAttributeValueResponseDTO x : c.getCustomAttributeValueResponseDTOList()) {            if (customAttributeStr != null && (customAttributeStr.equalsIgnoreCase(x.getCustomAttributeValueName()) || customAttributeStr.equalsIgnoreCase(x.getCustomAttributeValueCode()) || customAttributeStr.equalsIgnoreCase(x.getCustomAttributeValueExternalId()))) {                employeeCustomAttributeRequestDTO.setCustomAttributeValueNo(x.getCustomAttributeValueNo());                break;            }        }    }    if (customAttributeStr != null && employeeCustomAttributeRequestDTO.getCustomAttributeValueNo() == null) {            employeeCustomAttributeRequestDTO.setCustomAttributeValueStr(customAttributeStr);            employeeCustomAttributeRequestDTO.setCustomAttributeValueCode(customAttributeStr);            employeeCustomAttributeRequestDTO.setCustomAttributeValueExternalId(customAttributeStr);    }    return employeeCustomAttributeRequestDTO;}private Map<String, String> getCustomAttributesMap(HousingEmployeeRawData item) {    Map<String, String> customAttributeMaps = new HashMap<>();    customAttributeMaps.put(SCHEME.toUpperCase(), item.getCurrentMedicalScheme());    customAttributeMaps.put(GROUP.toUpperCase(), item.getGroup());    return customAttributeMaps;}private EmployeeRequestDTO buildEmployeeRequestDTO(HousingEmployeeRawData item, OverviewDTO mdmOverviewDTO, Long companyNo) {    EmployeeRequestDTO employeeRequestDto = new EmployeeRequestDTO();    buildImportEmployeeRequestDTO(item, mdmOverviewDTO, companyNo, employeeRequestDto);    return employeeRequestDto;} 
private void buildImportEmployeeRequestDTO(HousingEmployeeRawData item, OverviewDTO mdmOverviewDTO, Long companyNo, EmployeeRequestDTO employeeRequestDto) {    if (StringUtils.isNotEmpty(item.getStaffId())) {        employeeRequestDto.setStaffId(item.getStaffId());    }    if (StringUtils.isNotEmpty(item.getEmpNricNo())) {        employeeRequestDto.setIcNo(item.getEmpNricNo());    }    String maritalStatus = item.getMaritalStatus();    if (StringUtils.isNotEmpty(maritalStatus)) {        employeeRequestDto.setMaritalStatusNo(getValueFromTwoMaps(mdmOverviewDTO.getMaritalStatusNameValues(), mdmOverviewDTO.getMaritalStatusValues(), maritalStatus));    }    if (memberStartDate != null) {        employeeRequestDto.setEmploymentStartDate(memberStartDate);        employeeRequestDto.setCoverageStartDate(memberStartDate);    }    String gender = item.getGender();    if (StringUtils.isNotEmpty(gender)) {        employeeRequestDto.setGenderNo(getValueFromTwoMaps(mdmOverviewDTO.getGenderValues(), mdmOverviewDTO.getGenderNameValues(), gender));    }    String name = item.getName();    if (StringUtils.isNotEmpty(name)) {        employeeRequestDto.setEmployeeName(name);    }    LocalDate dob = item.getDob();    if (dob != null) {        employeeRequestDto.setDob(dob);    }    if (StringUtils.isNotEmpty(item.getEmailAdress())) {        employeeRequestDto.setEmail(item.getEmailAdress());    }}private Long getValueFromTwoMaps(Map<String, Long> map1, Map<String, Long> map2, String value) {    Long aLong = map1.get(value.toUpperCase());    if (aLong == null) {        aLong = map2.get(value.toUpperCase());    }    return aLong;}private EmployeeRequestDTO updateEmployeeRequestDTO(HousingEmployeeRawData item, OverviewDTO mdmOverviewDTO, Long companyNo, EmployeeRequestDTO employeeRequestDTO) {    buildImportEmployeeRequestDTO(item, mdmOverviewDTO, companyNo, employeeRequestDTO);    return employeeRequestDTO;}private List<ImportMemberResponseDTO> transformDependant(CompanyResponseDTO companyResponseDTO, String requestId) {    List<HousingDependantRawData> housingDependantRawDataList = housingDependantRawDataRepository.findByRequestId(requestId);    if (CollectionUtils.isEmpty(housingDependantRawDataList)) {        return Collections.emptyList();    }    Set<String> externalIdOfDEP = housingDependantRawDataList.stream()            .map(HousingDependantRawData::getStaffId)            .filter(Objects::nonNull)            .collect(Collectors.toSet());    List<ImportMemberResponseDTO> responses = new ArrayList<>();    Long companyNo = companyResponseDTO.getCompanyNo();    List<DependantResponseDTO> existingDependantResponseDTOs = common.getDependantsByExternalId(externalIdOfDEP, companyResponseDTO.getCompanyNo());    List<Long> dependantNos = existingDependantResponseDTOs.stream().map(DependantResponseDTO::getDependantNo).filter(Objects::nonNull).collect(Collectors.toList());    List<DependantCustomAttributeResponseDTO> dependantCustomAttributesByDependantNos = common.getDependantCustomAttributesByDependantNos(dependantNos);    List<DependantCustomAttributeResponseDTO> dependantCustomAttributeResponseDTOS = importDependantHelper.filterDependantCustomAttrByEffectedDate(dependantCustomAttributesByDependantNos);    // Create/get custom attribute    List<CompanyCustomAttributeResponseDTO> companyCustomAttributeResponseDTOS = common.getCompanyCustomAttributes(companyNo);    // Get overview    OverviewDTO overviewDTO = common.getMdmOverviewDTO(new HashSet<>());    Set<String> genders = common.collectSetNameAndSetCode(overviewDTO.getGenderNameValues(), overviewDTO.getGenderValues());    Set<String> relationships = common.collectSetNameAndSetCode(overviewDTO.getRelationshipCodeValues(),overviewDTO.getRelationShipValues());    List<ImportMemberResponseDTO> failureGenders = validateDependantGenders(housingDependantRawDataList, genders);    housingDependantRawDataList.removeIf(item -> common.isMemberIncludedInFailedResponses(failureGenders, item.getRecordId()));    List<ImportMemberResponseDTO> failureRelationships = validateDependantRelationships(housingDependantRawDataList, relationships);    housingDependantRawDataList.removeIf(item -> common.isMemberIncludedInFailedResponses(failureRelationships, item.getRecordId()));    // Collect employee staff ids    Set<String> employeeStaffIds = housingDependantRawDataList.stream().map(HousingDependantRawData::getStaffId).filter(Objects::nonNull).collect(Collectors.toSet());    List<EmployeeResponseDTO> employeeResponseDTOSByStaffId = common.getEmployeesByStaffIdsAndStatusCodesNotIn(employeeStaffIds, companyNo, Arrays.asList(StatusCode.CANCELLED));    // Collect employee icNos    Set<String> employeeIcNos = housingDependantRawDataList.stream().filter(x -> x.getStaffId() == null).map(HousingDependantRawData::getEmpNric).filter(Objects::nonNull).collect(Collectors.toSet());    List<EmployeeResponseDTO> employeeResponseDTOSByIcNos = common.getEmployee(employeeIcNos, companyNo);    // if any dependant has employee that does not exists in o2 -> remove    List<ImportMemberResponseDTO> failureEmployee = validateEmployees(employeeResponseDTOSByIcNos,employeeResponseDTOSByStaffId, housingDependantRawDataList);    housingDependantRawDataList.removeIf(item -> common.isMemberIncludedInFailedResponses(failureEmployee, item.getRecordId()));    responses.addAll(common.combineIntoOneCollection(failureGenders, failureRelationships, failureEmployee));    // 1 - process insert or update dependants case use ICNo    Map<Integer, String> rawDataRecordIdsAndIcNos = housingDependantRawDataList            .stream()            .collect(Collectors.toMap(HousingDependantRawData::getRecordId, HousingDependantRawData::getEmpNric));    List<DependantResponseDTO> findDependantResponseDTOSByIcNo = new ArrayList<>();    Map<ActionTypeEnum, List<HousingDependantRawData>> insertAndUpdateRawDataMap = common.splitRawDataIntoInsertAndUpdateList(housingDependantRawDataList, rawDataRecordIdsAndIcNos, Collections.emptyList(), findDependantResponseDTOSByIcNo, IC_NO, Boolean.FALSE);    List<HousingDependantRawData> insertDependants = new ArrayList<>();    insertDependants.addAll(insertAndUpdateRawDataMap.get(ActionTypeEnum.INSERT));    List<HousingDependantRawData> updateDependants = insertAndUpdateRawDataMap.get(ActionTypeEnum.UPDATE);    filterReinstateDependantRawData(updateDependants, insertDependants, findDependantResponseDTOSByIcNo);    List<ImportMemberResponseDTO> failedDuplicateEmployee2 = validateDuplicateAssignEmpForDep(insertDependants, employeeResponseDTOSByStaffId, employeeResponseDTOSByIcNos, findDependantResponseDTOSByIcNo);    insertDependants.removeIf(dependant -> common.isMemberIncludedInFailedResponses(failedDuplicateEmployee2, dependant.getRecordId()));    List<ImportMemberResponseDTO> validateUpdateRelationshipUpdate2 = filterInvalidDependantForUpdateAction(insertDependants, findDependantResponseDTOSByIcNo, overviewDTO);    insertDependants.removeIf(item -> common.isMemberIncludedInFailedResponses(validateUpdateRelationshipUpdate2, item.getRecordId()));    List<ImportMemberResponseDTO> failedDuplicateEmployee3 = validateDuplicateAssignEmpForDep(updateDependants, employeeResponseDTOSByStaffId, employeeResponseDTOSByIcNos, findDependantResponseDTOSByIcNo);    updateDependants.removeIf(dependant -> common.isMemberIncludedInFailedResponses(failedDuplicateEmployee3, dependant.getRecordId()));    List<ImportMemberResponseDTO> validateUpdateRelationshipUpdate3 = filterInvalidDependantForUpdateAction(updateDependants, findDependantResponseDTOSByIcNo, overviewDTO);    updateDependants.removeIf(item -> common.isMemberIncludedInFailedResponses(validateUpdateRelationshipUpdate3, item.getRecordId()));    List<ImportDepRequestDTO> importDepRequestDTOS = convertToImportDeptRequestDTO(insertDependants, overviewDTO, companyNo, employeeResponseDTOSByIcNos, employeeResponseDTOSByStaffId, companyCustomAttributeResponseDTOS);    List<ImportDepRequestDTO> updateDeptRequestDTOList = convertToImportDepRequestDTOForUpdate(updateDependants, overviewDTO, employeeResponseDTOSByIcNos,employeeResponseDTOSByStaffId, findDependantResponseDTOSByIcNo, companyNo,companyCustomAttributeResponseDTOS,dependantCustomAttributeResponseDTOS);    importDepRequestDTOS.forEach(importDepRequestDTO -> importDepRequestDTO.setDiImportMemberAction(DIImportMemberAction.CREATE));    updateDeptRequestDTOList.forEach(updateDepRequestDTO -> updateDepRequestDTO.setDiImportMemberAction(DIImportMemberAction.UPDATE));    List<ImportDepRequestDTO> depRequestDTOS = new ArrayList<>();    depRequestDTOS.addAll(importDepRequestDTOS);    depRequestDTOS.addAll(updateDeptRequestDTOList);    if (!CollectionUtils.isEmpty(depRequestDTOS)) {        depRequestDTOS.sort(Comparator.comparing(ImportDepRequestDTO::getLineNumber));        responses.addAll(common.submitMember(depRequestDTOS, MemberType.DEP.getValue()));    }    return responses;} 
public List<ImportMemberResponseDTO> validateDependantGenders(List<HousingDependantRawData> housingDependantRawData, Set<String> genders) {    List<ImportMemberResponseDTO> importMemberResponseDTOS = new ArrayList<>();    for (HousingDependantRawData item : housingDependantRawData) {        String gender = item.getGenderOfDependant();        if (StringUtils.isNotEmpty(gender)) {            Optional<String> optionalGender = genders.stream().filter(x -> x.trim().equalsIgnoreCase(gender)).findFirst();            if (!optionalGender.isPresent()) {                importMemberResponseDTOS.add(common.buildValidateFailMemberResponseDTO(item, common.buildErrorMessage(GENDER_NOT_FOUND, String.valueOf(item.getLineNumber()), gender)));            }        }    }    return importMemberResponseDTOS;}public List<ImportMemberResponseDTO> validateDependantRelationships(List<HousingDependantRawData> housingDependantRawData, Set<String> relationships) {    List<ImportMemberResponseDTO> importMemberResponseDTOS = new ArrayList<>();    for (HousingDependantRawData item : housingDependantRawData) {        String relationship = item.getRelationship();        if (StringUtils.isNotEmpty(relationship)) {            Optional<String> optionalRelationship = relationships.stream().filter(x -> x.trim().equalsIgnoreCase(relationship)).findFirst();            if (!optionalRelationship.isPresent()) {                importMemberResponseDTOS.add(common.buildValidateFailMemberResponseDTO(item, common.buildErrorMessage(RELATIONSHIP_NOT_FOUND, String.valueOf(item.getLineNumber()), relationship)));            }        }    }    return importMemberResponseDTOS;}public List<ImportMemberResponseDTO> validateEmployees(List<EmployeeResponseDTO> employeeResponseDTOSByIcNo, List<EmployeeResponseDTO> employeeResponseDTOSByStaffId, List<HousingDependantRawData> housingDependantRawData) {    List<ImportMemberResponseDTO> importMemberResponseDTOS = new ArrayList<>();    Set<String> existingEmployeeIcNos = employeeResponseDTOSByIcNo.stream().map(EmployeeResponseDTO::getIcNo).filter(Objects::nonNull).collect(Collectors.toSet());    Set<String> existingEmployeeStaffIds = employeeResponseDTOSByStaffId.stream().map(EmployeeResponseDTO::getStaffId).filter(Objects::nonNull).collect(Collectors.toSet());    for (HousingDependantRawData item : housingDependantRawData) {        String lineNumber = String.valueOf(item.getLineNumber());        String empNric = item.getEmpNric();        String empStaffId = item.getStaffId();        if(StringUtils.isEmpty(empStaffId) && StringUtils.isNotEmpty(empNric)) {            if (!existingEmployeeIcNos.contains(empNric)) {                importMemberResponseDTOS.add(common.buildValidateFailMemberResponseDTO(item, common.buildErrorMessage(EMPLOYEE_DOES_NOT_EXIST, lineNumber, empNric)));                continue;            }            if (isNotActiveOrSuspendedEmployeeByIcNo(employeeResponseDTOSByIcNo, item)) {                importMemberResponseDTOS.add(common.buildValidateFailMemberResponseDTO(item, common.buildErrorMessage(EMPLOYEE_IC_STATUS_CODE_NOT_ACTIVE_OR_SUSPENDED, lineNumber, empNric)));            }        } else if(StringUtils.isNotEmpty(empStaffId)){            if (!existingEmployeeStaffIds.contains(empStaffId)) {                importMemberResponseDTOS.add(common.buildValidateFailMemberResponseDTO(item, common.buildErrorMessage(EMPLOYEE_DOES_NOT_EXIST, lineNumber, empStaffId)));                continue;            }            if (isNotActiveOrSuspendedEmployeeByStaffId(employeeResponseDTOSByStaffId, item)) {                importMemberResponseDTOS.add(common.buildValidateFailMemberResponseDTO(item, common.buildErrorMessage(EMPLOYEE_STAFF_ID_STATUS_CODE_NOT_ACTIVE_OR_SUSPENDED, lineNumber, empStaffId)));            }        }    }    return importMemberResponseDTOS;}private boolean isNotActiveOrSuspendedEmployeeByIcNo(List<EmployeeResponseDTO> employeeResponseDTOS, HousingDependantRawData housingDependantRawData) {    Optional<EmployeeResponseDTO> optionalEmployeeResponseDTO = findEmployeeByIcNoForDuplicatedKeyCase(housingDependantRawData, employeeResponseDTOS);    if (optionalEmployeeResponseDTO.isPresent()            && !Arrays.asList(StatusCode.ACTIVE.getValue(), StatusCode.SUSPENDED.getValue()).contains(optionalEmployeeResponseDTO.get().getStatusCode())) {        return true;    }    return false;}public List<HousingDependantRawData> filterReinstateDependantRawData(List<HousingDependantRawData> updateHousingDependantRawData, List<HousingDependantRawData> insertHousingDependantRawData, List<DependantResponseDTO> dependantResponseDTOS) {    List<HousingDependantRawData> reinstateEmployees = new ArrayList<>();    Iterator<HousingDependantRawData> iterator = updateHousingDependantRawData.iterator();    while (iterator.hasNext()) {        HousingDependantRawData item = iterator.next();        Optional<DependantResponseDTO> optionalDependantResponseDTO = getDependantResponseDTOForDuplicatedKeyCase(dependantResponseDTOS, item);        if (optionalDependantResponseDTO.isPresent() &&                StatusCode.TERMINATED.equals(optionalDependantResponseDTO.get().getStatusCode())) {            insertHousingDependantRawData.add(item);            iterator.remove();        }    }    return reinstateEmployees;}public Optional<EmployeeResponseDTO> findEmployeeByIcNoForDuplicatedKeyCase(HousingDependantRawData item, List<EmployeeResponseDTO> employeeResponseDTOS) {    List<EmployeeResponseDTO> employeeResponseDTOList = employeeResponseDTOS.stream()            .filter(x -> x.getIcNo().equalsIgnoreCase(item.getEmpNric()))            .collect(Collectors.toList());    if (employeeResponseDTOList.size() > 1) {        Collections.sort(employeeResponseDTOList, (e1, e2) -> e2.getEmployeeCode().compareTo(e1.getEmployeeCode()));        EmployeeResponseDTO responseDTO = employeeResponseDTOList.get(0);        return employeeResponseDTOList.stream().filter(x -> x.getEmployeeCode().equalsIgnoreCase(responseDTO.getEmployeeCode())).findAny();    }    return findEmployeeByIcNo(item, employeeResponseDTOS);}private Optional<EmployeeResponseDTO> findEmployeeByIcNo(HousingDependantRawData item, List<EmployeeResponseDTO> employeeResponseDTOS) {    return employeeResponseDTOS.stream().filter(x -> x.getIcNo().equalsIgnoreCase(item.getEmpNric())).findAny();}private boolean isNotActiveOrSuspendedEmployeeByStaffId(List<EmployeeResponseDTO> employeeResponseDTOS, HousingDependantRawData housingDependantRawData) {    Optional<EmployeeResponseDTO> optionalEmployeeResponseDTO = findEmployeeByStaffIdForDuplicatedKeyCase(housingDependantRawData, employeeResponseDTOS);    if (optionalEmployeeResponseDTO.isPresent()            && !Arrays.asList(StatusCode.ACTIVE.getValue(), StatusCode.SUSPENDED.getValue()).contains(optionalEmployeeResponseDTO.get().getStatusCode())) {        return true;    }    return false;}private Optional<EmployeeResponseDTO> findEmployeeByStaffId(HousingDependantRawData item, List<EmployeeResponseDTO> employeeResponseDTOS) {    return employeeResponseDTOS.stream().filter(x -> x.getStaffId().equalsIgnoreCase(item.getStaffId())).findAny();}public Optional<EmployeeResponseDTO> findEmployeeByStaffIdForDuplicatedKeyCase(HousingDependantRawData item, List<EmployeeResponseDTO> employeeResponseDTOS) {    List<EmployeeResponseDTO> employeeResponseDTOList = employeeResponseDTOS.stream()            .filter(x -> x.getStaffId().equalsIgnoreCase(item.getStaffId()))            .collect(Collectors.toList());    if (employeeResponseDTOList.size() > 1) {        Collections.sort(employeeResponseDTOList, (e1, e2) -> e2.getEmployeeCode().compareTo(e1.getEmployeeCode()));        EmployeeResponseDTO responseDTO = employeeResponseDTOList.get(0);        return employeeResponseDTOList.stream().filter(x -> x.getEmployeeCode().equalsIgnoreCase(responseDTO.getEmployeeCode())).findAny();    }    return findEmployeeByStaffId(item, employeeResponseDTOS);} 

--------------------------
public Optional<DependantResponseDTO> getDependantResponseDTOForDuplicatedKeyCase(List<DependantResponseDTO> dependantResponseDTOList, HousingDependantRawData housingDependantRawData) {    List<DependantResponseDTO> dependantResponseDTOS;    dependantResponseDTOS = dependantResponseDTOList.stream().filter(x -> housingDependantRawData.getDepNric() != null && housingDependantRawData.getDepNric().equalsIgnoreCase(x.getIcNo())).collect(Collectors.toList());    if (dependantResponseDTOS.size() > 1) {        Collections.sort(dependantResponseDTOS, (d1, d2) -> d2.getDependantCode().compareTo(d1.getDependantCode()));        DependantResponseDTO responseDTO = dependantResponseDTOS.get(0);        return dependantResponseDTOS.stream()                .filter(x -> x.getDependantCode().equalsIgnoreCase(responseDTO.getDependantCode()))                .findAny();    }    return getDependantResponseDTO(dependantResponseDTOList, housingDependantRawData);}private Optional<DependantResponseDTO> getDependantResponseDTO(List<DependantResponseDTO> dependantResponseDTOList, HousingDependantRawData housingDependantRawData) {            return dependantResponseDTOList.stream().filter(d -> housingDependantRawData.getDepNric() != null && housingDependantRawData.getDepNric().equalsIgnoreCase(d.getIcNo())).findAny();}public List<ImportMemberResponseDTO> validateDuplicateAssignEmpForDep(List<HousingDependantRawData> items, List<EmployeeResponseDTO> employeesByStaffIdExists, List<EmployeeResponseDTO> employeesByIcNoExists, List<DependantResponseDTO> existingDependantResponseDTOs) {    List<ImportMemberResponseDTO> importMemberResponseDTOS = new ArrayList<>();    for (HousingDependantRawData item : items) {        String lineNumber = String.valueOf(item.getLineNumber());        String depNric = item.getDepNric();        if (StringUtils.isEmpty(item.getStaffId())) {            Optional<EmployeeResponseDTO> optionalEmployeeResponseDTO = findEmployeeByIcNoForDuplicatedKeyCase(item, employeesByIcNoExists);            Optional<DependantResponseDTO> dependantResponseDTO = getDependantResponseDTOForDuplicatedKeyCase(existingDependantResponseDTOs, item);            if (optionalEmployeeResponseDTO.isPresent() && dependantResponseDTO.isPresent() && optionalEmployeeResponseDTO.get().getEmployeeNo() != dependantResponseDTO.get().getEmployeeNo()) {                importMemberResponseDTOS.add(common.buildValidateFailMemberResponseDTO(item, common.buildErrorMessage(DEPENDANT_NRIC, String.valueOf(item.getLineNumber()), item.getDepNric())));            }        } else {            Optional<EmployeeResponseDTO> optionalEmployeeResponseDTO = findEmployeeByStaffIdForDuplicatedKeyCase(item, employeesByStaffIdExists);            Optional<DependantResponseDTO> dependantResponseDTO = getDependantResponseDTOForDuplicatedKeyCase(existingDependantResponseDTOs, item);            if (optionalEmployeeResponseDTO.isPresent() && dependantResponseDTO.isPresent() && optionalEmployeeResponseDTO.get().getEmployeeNo() != dependantResponseDTO.get().getEmployeeNo()) {                importMemberResponseDTOS.add(common.buildValidateFailMemberResponseDTO(item, common.buildErrorMessage(DEPENDANT_NRIC, lineNumber, depNric)));            }        }    }    return importMemberResponseDTOS;}public List<ImportMemberResponseDTO> filterInvalidDependantForUpdateAction(List<HousingDependantRawData> items, List<DependantResponseDTO> existingDependantResponseDTOs, OverviewDTO overviewDTO) {    List<ImportMemberResponseDTO> importMemberResponseDTOList = new ArrayList<>();    for (HousingDependantRawData rawDept : items) {        Optional<DependantResponseDTO> optionalDependantResponseDTO = getDependantResponseDTOForDuplicatedKeyCase(existingDependantResponseDTOs, rawDept);        if (optionalDependantResponseDTO.isPresent() && StringUtils.isNotEmpty(rawDept.getRelationship())) {            DependantResponseDTO dependantResponseDTO = optionalDependantResponseDTO.get();            Long relationShipNo = common.getValueFromTwoMaps(overviewDTO.getRelationShipValues(), overviewDTO.getRelationshipCodeValues(), rawDept.getRelationship());            if (dependantResponseDTO.getCoverageStartDate() != null && !TimeZoneUtil.now().isBefore(dependantResponseDTO.getCoverageStartDate()) && !dependantResponseDTO.getRelationshipNo().equals(relationShipNo) && StatusCode.ACTIVE.equals(dependantResponseDTO.getStatusCode())) {                importMemberResponseDTOList.add(common.buildValidateFailMemberResponseDTO(rawDept, String.format(ServiceConstant.ERROR_CANNOT_UPDATE_RELATIONSHIP, rawDept.getLineNumber(), rawDept.getDepNric())));            }        }    }    return importMemberResponseDTOList;}private List<ImportDepRequestDTO> convertToImportDeptRequestDTO(List<HousingDependantRawData> housingDependantRawData, OverviewDTO overviewDTO,                                                                Long companyNo, List<EmployeeResponseDTO> employeeResponseDTOSByIcNo,                                                                List<EmployeeResponseDTO> employeeResponseDTOSByStaffId,                                                                List<CompanyCustomAttributeResponseDTO> companyCustomAttributeResponseDTOS                                                                  ) {    List<ImportDepRequestDTO> importDepRequestDTOList = new ArrayList<>();    housingDependantRawData.forEach(item -> {        Optional<EmployeeResponseDTO> optionalEmployee;        if (StringUtils.isEmpty(item.getStaffId())) {            optionalEmployee = findEmployeeByIcNoForDuplicatedKeyCase(item, employeeResponseDTOSByIcNo);        } else {            optionalEmployee = findEmployeeByStaffIdForDuplicatedKeyCase(item, employeeResponseDTOSByStaffId);        }        DependantRequestDTO dependantRequestDTO = buildDependantRequestDTO(item, overviewDTO, companyNo);        ImportDepRequestDTO importDepRequestDTO = ImportDepRequestDTO.builder()                        .statusRequestDTO(StatusRequestDTO.builder()                        .build())                .overviewInfo(dependantRequestDTO)                .attributes(DependantAttributeEnrollmentRequestDTO.builder()                        .dependantCustomAttributeDTOs(buildDependantCustomAttribute( companyCustomAttributeResponseDTOS, new ArrayList<>(), true))                        .build())                .planScheme(new MemberPlanRequestDTO())                .build();        importDepRequestDTO.setRecordId(item.getRecordId());        importDepRequestDTO.setLineNumber(item.getLineNumber());        optionalEmployee.ifPresent(employeeResponseDTO -> importDepRequestDTO.getOverviewInfo().setEmployeeNo(employeeResponseDTO.getEmployeeNo()));        importDepRequestDTOList.add(importDepRequestDTO);    });    return importDepRequestDTOList;}private DependantRequestDTO buildDependantRequestDTO(HousingDependantRawData item, OverviewDTO mdmOverviewDTO, Long companyNo) {    DependantRequestDTO dependantRequestDTO = new DependantRequestDTO();    buildImportDependantRequestDTO(item, mdmOverviewDTO, companyNo, dependantRequestDTO);    return dependantRequestDTO;}private void buildImportDependantRequestDTO(HousingDependantRawData item, OverviewDTO mdmOverviewDTO, Long companyNo, DependantRequestDTO dependantRequestDTO) {    if (StringUtils.isNotEmpty(item.getDepNric())) {        dependantRequestDTO.setIcNo(item.getDepNric());    }    if (StringUtils.isNotEmpty(item.getNameOfDependent())) {        dependantRequestDTO.setDependantName(item.getNameOfDependent());    }    if (item.getDobOfDependant() != null) {        dependantRequestDTO.setDob(item.getDobOfDependant());    }    String gender = item.getGenderOfDependant();    if (StringUtils.isNotEmpty(gender)) {        dependantRequestDTO.setGenderNo(getValueFromTwoMaps(mdmOverviewDTO.getGenderValues(), mdmOverviewDTO.getGenderNameValues(), gender));    }    String relationship = item.getRelationship();    if (StringUtils.isNotEmpty(relationship)) {        dependantRequestDTO.setRelationshipNo(getValueFromTwoMaps(mdmOverviewDTO.getRelationShipValues(), mdmOverviewDTO.getRelationshipCodeValues(), relationship));    }    if (dependantStartDate != null) {        dependantRequestDTO.setDependantStartDate(dependantStartDate);        dependantRequestDTO.setCoverageStartDate(dependantStartDate);    }    dependantRequestDTO.setCompanyNo(companyNo);    dependantRequestDTO.setPhysicalCardFlag(false);} 

-----------------------
private List<ImportDepRequestDTO> convertToImportDepRequestDTOForUpdate(List<HousingDependantRawData> housingDependantRawData,                                                                        OverviewDTO overviewDTO, List<EmployeeResponseDTO> employeeResponseDTOSByIcNo,                                                                        List<EmployeeResponseDTO> employeeResponseDTOSByStaffId,                                                                        List<DependantResponseDTO> dependantResponseDTOS,                                                                        Long companyNo,List<CompanyCustomAttributeResponseDTO> companyCustomAttributeResponseDTOS,                                                                        List<DependantCustomAttributeResponseDTO> dependantCustomAttributeResponseDTOS                                                                         ) {    List<ImportDepRequestDTO> importDepRequestDTOS = new ArrayList<>();    housingDependantRawData.forEach(item -> {        Optional<EmployeeResponseDTO> optionalEmployee;        if (StringUtils.isEmpty(item.getStaffId())) {            optionalEmployee = findEmployeeByIcNoForDuplicatedKeyCase(item, employeeResponseDTOSByIcNo);        } else {            optionalEmployee = findEmployeeByStaffIdForDuplicatedKeyCase(item, employeeResponseDTOSByStaffId);        }        Optional<DependantResponseDTO> existDependant = getDependantResponseDTOForDuplicatedKeyCase(dependantResponseDTOS, item);        if (existDependant.isPresent()) {            DependantResponseDTO dependantResponseDTO = existDependant.get();            Long employeeNo = dependantResponseDTO.getEmployeeNo();            List<DependantCustomAttributeResponseDTO> dependantCustomAttributeResponseDTOList = dependantCustomAttributeResponseDTOS.stream().filter(x -> x.getDependantNo().equals(dependantResponseDTO.getEmployeeNo())).collect(Collectors.toList());            DependantRequestDTO dependantRequestDTO = updateDependantRequestDTO(item, overviewDTO, companyNo, common.convertDependantRequestDTO(dependantResponseDTO));            ImportDepRequestDTO importDepRequestDTO = ImportDepRequestDTO.builder()                    .statusRequestDTO(StatusRequestDTO.builder()                    .build())                    .overviewInfo(dependantRequestDTO)                    .attributes(DependantAttributeEnrollmentRequestDTO.builder()                    .dependantCustomAttributeDTOs(buildDependantCustomAttribute( companyCustomAttributeResponseDTOS, dependantCustomAttributeResponseDTOList, false))                    .build())                    .planScheme(new MemberPlanRequestDTO())                    .build();            importDepRequestDTO.setRecordId(item.getRecordId());            importDepRequestDTO.setLineNumber(item.getLineNumber());            if (StringUtils.isEmpty(item.getStaffId()) && StringUtils.isEmpty(item.getEmpNric())) {                importDepRequestDTO.getOverviewInfo().setEmployeeNo(employeeNo);            } else {                optionalEmployee.ifPresent(employeeResponseDTO -> importDepRequestDTO.getOverviewInfo().setEmployeeNo(employeeResponseDTO.getEmployeeNo()));            }            importDepRequestDTO.getOverviewInfo().setDependantNo(dependantResponseDTO.getDependantNo());            importDepRequestDTOS.add(importDepRequestDTO);        }    });    return importDepRequestDTOS;}private DependantRequestDTO updateDependantRequestDTO(HousingDependantRawData item, OverviewDTO mdmOverviewDTO, Long companyNo, DependantRequestDTO dependantRequestDTO) {    buildImportDependantRequestDTO(item, mdmOverviewDTO, companyNo, dependantRequestDTO);    return dependantRequestDTO;}private List<HousingEmployeeFailure> buildMemberFailures(List<ImportMemberResponseDTO> importMemberResponseDTOS) {    Map<Integer, String> mapRecordId = importMemberResponseDTOS.stream()            .collect(HashMap::new, (map, value) -> map.put(value.getRecordId(), value.getErrorMsg()), HashMap::putAll);    List<HousingEmployeeRawData> housingEmployeeRawData = getHousingEmployeeRawData(new ArrayList<>(mapRecordId.keySet()));    List<HousingEmployeeFailure> employeeFailures = new ArrayList<>();    for (HousingEmployeeRawData item : housingEmployeeRawData) {        HousingEmployeeFailure housingEmployeeFailure = new HousingEmployeeFailure();        employeeFailures.add(convertMemberFailure(housingEmployeeFailure,                item, mapRecordId.get(item.getRecordId())));    }    return employeeFailures;}private List<HousingEmployeeRawData> getHousingEmployeeRawData(List<Integer> employeeNos) {    List<HousingEmployeeRawData> searchData = new ArrayList<>();    int count = 0;    if (employeeNos.size() > MAX_IN_LIST_COUNT) {        List<Integer> employeeNosInQuery = new ArrayList<>();        for (Integer employeeNo : employeeNos) {            if (count == MAX_IN_LIST_COUNT) {                searchData.addAll(housingEmployeeRawDataRepository.findByRecordIdIn(employeeNosInQuery));                employeeNosInQuery = new ArrayList<>();                count = 0;            }            count++;            employeeNosInQuery.add(employeeNo);        }        searchData.addAll(housingEmployeeRawDataRepository.findByRecordIdIn(employeeNosInQuery));    } else {        searchData.addAll(housingEmployeeRawDataRepository.findByRecordIdIn(new ArrayList<>(employeeNos)));    }    return searchData;}private HousingEmployeeFailure convertMemberFailure(HousingEmployeeFailure failure, HousingEmployeeRawData item, String message) {    failure.setBatchId(item.getBatchId());    failure.setInterfaceFileName(item.getInterfaceFileName());    failure.setFileProcessedTime(item.getFileProcessedTime());    failure.setLineNumber(item.getLineNumber());    failure.setTransactionId(UUID.randomUUID().toString());    failure.setRetryTime(0);    failure.setProgressType(ProgressTypeEnum.TRANSFORM_AND_LOAD_PROCESS);    failure.setReasonToFail(FailureReasonTypeEnum.BUSINESS_FAILURE);    failure.setMessageContent(common.getMessage(message));    failure.setStatusCode(TransformResultCodeEnum.BUSINESS_FAILED);    failure.setCreatedBy(DI_JOB);    failure.setCreatedOn(new Timestamp(System.currentTimeMillis()));    failure.setModifiedBy(DI_JOB);    failure.setModifiedOn(new Timestamp(System.currentTimeMillis()));    failure.setName(item.getName());    failure.setStaffId(item.getStaffId());    failure.setEmpNricNo(item.getEmpNricNo());    failure.setDob(item.getDob());    failure.setGender(item.getGender());    failure.setMaritalStatus(item.getMaritalStatus());    failure.setTerminationDate(item.getTerminationDate());    failure.setGroup(item.getGroup());    failure.setCurrentMedicalScheme(item.getCurrentMedicalScheme());    failure.setRequestId(item.getRequestId());    failure.setEmailAdress(item.getEmailAdress());    return failure;}@Override@Transactionalpublic void cleanData(EntityEnum entityEnum, DIClientDTO diClientDTO) {    if (entityEnum == EntityEnum.EMPLOYEE) {        housingEmployeeRawDataRepository.deleteAllInBatch();    } else if (entityEnum == EntityEnum.DEPENDANT) {        housingDependantRawDataRepository.deleteAllInBatch();    }}@Overridepublic void updateHistoryStatusEmployee(Long historyId, String requestId) {    Optional<ImportHistory> historyOptional = importHistoryRepository.findById(historyId);    if (historyOptional.isPresent()) {        String status = ImportMemberStatusEnum.COMPLETED.getValue();        List<HousingEmployeeSuccess> successMembers = housingEmployeeSuccessRepository.findByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(requestId);        List<HousingEmployeeFailure> failureMembers = housingEmployeeFailureRepository.findByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(requestId);        if (common.isCollectionEmpty(successMembers)) {            status = ImportMemberStatusEnum.FAILED.getValue();        } else if (!common.isCollectionEmpty(failureMembers)) {            status = ImportMemberStatusEnum.PARTIAL_COMPLETED.getValue();        }        historyOptional.get().setStatus(status);        historyOptional.get().setCompletedOn(LocalDateTime.now());        importHistoryRepository.save(historyOptional.get());        log.info("Updated import history id {} to status {}", HtmlUtils.htmlEscape(String.valueOf(historyId)), HtmlUtils.htmlEscape(status));    } else {        log.error("Can't find import history with id {}", HtmlUtils.htmlEscape(String.valueOf(historyId)));    }} 

----------------------
@Overridepublic void updateHistoryStatusDependant(Long historyId, String requestId) {    Optional<ImportHistory> historyOptional = importHistoryRepository.findById(historyId);    if (historyOptional.isPresent()) {        String status = ImportMemberStatusEnum.COMPLETED.getValue();        List<HousingDependantSuccess> successMembers = housingDependantSuccessRepository.findByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(requestId);        List<HousingDependantFailure> failureMembers = housingDependantFailureRepository.findByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(requestId);        if (common.isCollectionEmpty(successMembers)) {            status = ImportMemberStatusEnum.FAILED.getValue();        } else if (!common.isCollectionEmpty(failureMembers)) {            status = ImportMemberStatusEnum.PARTIAL_COMPLETED.getValue();        }        historyOptional.get().setStatus(status);        historyOptional.get().setCompletedOn(LocalDateTime.now());        importHistoryRepository.save(historyOptional.get());        log.info("Updated import history id {} to status {}", HtmlUtils.htmlEscape(String.valueOf(historyId)), HtmlUtils.htmlEscape(status));    } else {        log.error("Can't find import history with id {}", HtmlUtils.htmlEscape(String.valueOf(historyId)));    }}private List<HousingEmployeeSuccess> buildMemberSuccesses(List<ImportMemberResponseDTO> importMemberResponseDTOS) {    List<Integer> recordIDs = importMemberResponseDTOS.stream().map(ImportMemberResponseDTO::getRecordId).collect(Collectors.toList());    List<HousingEmployeeRawData> housingEmployeeSuccesses = getHousingEmployeeRawData(recordIDs);    List<HousingEmployeeSuccess> syngentaEmployeeSuccesses = new ArrayList<>();    for (HousingEmployeeRawData item : housingEmployeeSuccesses) {        HousingEmployeeSuccess syngentaEmployeeSuccess = new HousingEmployeeSuccess();        syngentaEmployeeSuccesses.add(convertMemberSuccess(syngentaEmployeeSuccess, item));    }    return syngentaEmployeeSuccesses;}private HousingEmployeeSuccess convertMemberSuccess(HousingEmployeeSuccess success, HousingEmployeeRawData item) {    success.setBatchId(item.getBatchId());    success.setInterfaceFileName(item.getInterfaceFileName());    success.setFileProcessedTime(item.getFileProcessedTime());    success.setLineNumber(item.getLineNumber());    success.setTransactionId(UUID.randomUUID().toString());    success.setRemark(SUCCESS_MSG);    success.setCreatedDate(new Timestamp(System.currentTimeMillis()));    success.setUpdatedDate(new Timestamp(System.currentTimeMillis()));    success.setName(item.getName());    success.setStaffId(item.getStaffId());    success.setEmpNricNo(item.getEmpNricNo());    success.setDob(item.getDob());    success.setGender(item.getGender());    success.setMaritalStatus(item.getMaritalStatus());    success.setTerminationDate(item.getTerminationDate());    success.setGroup(item.getGroup());    success.setCurrentMedicalScheme(item.getCurrentMedicalScheme());    success.setRequestId(item.getRequestId());    success.setEmailAdress(item.getEmailAdress());    return success;}private boolean sendLogEmailForEmployee(List<HousingEmployeeSuccess> employeeSuccesses, List<HousingEmployeeFailure> EmployeeFailures, String companyName, String pathLog, String recipients, String subject) {    List<AttachmentFileRequestDTO> attachmentFileRequestDTOS = new ArrayList<>(logService.buildFileMemberLog(pathLog, employeeSuccesses, EmployeeFailures, 0L, (long) employeeSuccesses.size()));    EmailRequestDTO emailRequestDTO = new EmailRequestDTO();    try {        emailRequestDTO.setBody(logService.buildTemplateBodyLogDaily(companyName));    } catch (IOException | TemplateException e) {        emailRequestDTO.setBody(StringUtils.EMPTY);        log.error(EXCEPTION, e);    }    emailRequestDTO.setTo(new String[]{recipients});    emailRequestDTO.setSubject(subject);    emailRequestDTO.setFiles(attachmentFileRequestDTOS);    EmailResponseDTO emailResponseDTO = notificationApiIntegration.sendEmail(emailRequestDTO);    return emailResponseDTO.isSent();}@Overridepublic GenericDIClientDataSource buildGenericClientDataSource(DIClientDTO diClientDTO) {    return null;}@Overridepublic boolean isClientMatching(CompanyResponseDTO companyResponseDTO, EntityEnum entityEnum) {    if (EntityEnum.DEPENDANT.equals(entityEnum) && CORPORATE_ID_PIRELLI.equalsIgnoreCase(companyResponseDTO.getOhmCorporateId())) {        return false;    }    return CharacterConstant.S.equalsIgnoreCase(companyResponseDTO.getImportMemberTemplate());}@Overridepublic void handleApiException(String requestId, EntityEnum entityEnum) {    if (EntityEnum.DEPENDANT == entityEnum) {        housingDependantRawDataRepository.deleteByRequestId(requestId);        housingDependantFailureRepository.deleteByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(requestId);    } else if (EntityEnum.EMPLOYEE == entityEnum) {        housingEmployeeRawDataRepository.deleteByRequestId(requestId);        housingEmployeeFailureRepository.deleteByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(requestId);    }}public List<HousingDependantSuccess> buildDependantSuccesses(List<ImportMemberResponseDTO> importMemberResponseDTOS) {    List<Integer> recordIDs = importMemberResponseDTOS.stream().map(ImportMemberResponseDTO::getRecordId).collect(Collectors.toList());    List<HousingDependantRawData> dependantRawDataList = getHousingDependantRawData(recordIDs);    List<HousingDependantSuccess> standardDependantSuccesses = new ArrayList<>();    for (HousingDependantRawData item : dependantRawDataList) {        HousingDependantSuccess housingDependantSuccess = new HousingDependantSuccess();        standardDependantSuccesses.add(convertDependantSuccess(housingDependantSuccess, item));    }    return standardDependantSuccesses;}public List<HousingDependantFailure> buildDependantFailures(List<ImportMemberResponseDTO> importMemberResponseDTOS) {    Map<Integer, String> mapRecordId = importMemberResponseDTOS.stream()            .collect(HashMap::new, (map, value) -> map.put(value.getRecordId(), value.getErrorMsg()), HashMap::putAll);    List<HousingDependantRawData> dependantRawDataList = getHousingDependantRawData(new ArrayList<>(mapRecordId.keySet()));    List<HousingDependantFailure> standardDependantFailures = new ArrayList<>();    for (HousingDependantRawData item : dependantRawDataList) {        HousingDependantFailure housingDependantFailure = new HousingDependantFailure();        standardDependantFailures.add(convertDependantFailure(housingDependantFailure,                item, mapRecordId.get(item.getRecordId())));    }    return standardDependantFailures;}private List<HousingDependantRawData> getHousingDependantRawData(List<Integer> employeeNos) {    List<HousingDependantRawData> searchData = new ArrayList<>();    int count = 0;    if (employeeNos.size() > MAX_IN_LIST_COUNT) {        List<Integer> employeeNosInQuery = new ArrayList<>();        for (Integer employeeNo : employeeNos) {            if (count == MAX_IN_LIST_COUNT) {                searchData.addAll(housingDependantRawDataRepository.findByRecordIdIn(employeeNosInQuery));                employeeNosInQuery = new ArrayList<>();                count = 0;            }            count++;            employeeNosInQuery.add(employeeNo);        }        searchData.addAll(housingDependantRawDataRepository.findByRecordIdIn(employeeNosInQuery));    } else {        searchData.addAll(housingDependantRawDataRepository.findByRecordIdIn(new ArrayList<>(employeeNos)));    }    return searchData;} 

-----------------------
private HousingDependantFailure convertDependantFailure(HousingDependantFailure failure, HousingDependantRawData item, String message) {        failure.setBatchId(item.getBatchId());        failure.setInterfaceFileName(item.getInterfaceFileName());        failure.setFileProcessedTime(item.getFileProcessedTime());        failure.setLineNumber(item.getLineNumber());        failure.setTransactionId(UUID.randomUUID().toString());        failure.setRetryTime(0);        failure.setReasonToFail(FailureReasonTypeEnum.BUSINESS_FAILURE);        failure.setProgressType(ProgressTypeEnum.TRANSFORM_AND_LOAD_PROCESS);        failure.setMessageContent(common.getMessage(message));        failure.setStatusCode(TransformResultCodeEnum.BUSINESS_FAILED);        failure.setCreatedBy(DI_JOB);        failure.setCreatedOn(new Timestamp(System.currentTimeMillis()));        failure.setModifiedBy(DI_JOB);        failure.setModifiedOn(new Timestamp(System.currentTimeMillis()));        failure.setStaffId(item.getStaffId());        failure.setEmpNric(item.getEmpNric());        failure.setDepNric(item.getDepNric());        failure.setNameOfDependent(item.getNameOfDependent());        failure.setNameOfEmployee(item.getNameOfEmployee());        failure.setGenderOfEmployee(item.getGenderOfEmployee());        failure.setDateLeftService(item.getDateLeftService());        failure.setDobOfDependant(item.getDobOfDependant());        failure.setRelationship(item.getRelationship());        failure.setCurrentMedicalScheme(item.getCurrentMedicalScheme());        failure.setGenderOfDependant(item.getGenderOfDependant());        failure.setGroup(item.getGroup());        failure.setGenderOfEmployee(item.getGenderOfEmployee());        failure.setRequestId(item.getRequestId());        return failure;    }    private HousingDependantSuccess convertDependantSuccess(HousingDependantSuccess success, HousingDependantRawData item) {        success.setBatchId(item.getBatchId());        success.setInterfaceFileName(item.getInterfaceFileName());        success.setFileProcessedTime(item.getFileProcessedTime());        success.setLineNumber(item.getLineNumber());        success.setTransactionId(UUID.randomUUID().toString());        success.setRemark(SUCCESS_MSG);        success.setCreatedDate(new Timestamp(System.currentTimeMillis()));        success.setUpdatedDate(new Timestamp(System.currentTimeMillis()));        success.setStaffId(item.getStaffId());        success.setEmpNric(item.getEmpNric());        success.setDepNric(item.getDepNric());        success.setNameOfDependent(item.getNameOfDependent());        success.setNameOfEmployee(item.getNameOfEmployee());        success.setGenderOfEmployee(item.getGenderOfEmployee());        success.setDateLeftService(item.getDateLeftService());        success.setDobOfDependant(item.getDobOfDependant());        success.setRelationship(item.getRelationship());        success.setCurrentMedicalScheme(item.getCurrentMedicalScheme());        success.setGenderOfDependant(item.getGenderOfDependant());        success.setGroup(item.getGroup());        success.setGenderOfEmployee(item.getGenderOfEmployee());        success.setRequestId(item.getRequestId());        return success;    }    private boolean sendLogEmailForDependant(List<HousingDependantSuccess> housingDependantSuccesses, List<HousingDependantFailure> housingDependantFailures, String companyName, String pathLog, String recipients, String subject) {        List<AttachmentFileRequestDTO> attachmentFileRequestDTOS = new ArrayList<>(logService.buildFileMemberLog(pathLog, housingDependantSuccesses, housingDependantFailures, 0L, (long) housingDependantSuccesses.size()));        EmailRequestDTO emailRequestDTO = new EmailRequestDTO();        try {            emailRequestDTO.setBody(logService.buildTemplateBodyLogDaily(companyName));        } catch (IOException | TemplateException e) {            emailRequestDTO.setBody(StringUtils.EMPTY);            log.error(EXCEPTION, e);        }        emailRequestDTO.setTo(new String[]{recipients});        emailRequestDTO.setSubject(subject);        emailRequestDTO.setFiles(attachmentFileRequestDTOS);        EmailResponseDTO emailResponseDTO = notificationApiIntegration.sendEmail(emailRequestDTO);        return emailResponseDTO.isSent();    }    private List<DependantCustomAttributeRequestDTO> buildDependantCustomAttribute( List<CompanyCustomAttributeResponseDTO> companyCustomAttributeResponseDTOS, List<DependantCustomAttributeResponseDTO> dependantCustomAttributeResponseDTOS, boolean isNewHire) {        List<DependantCustomAttributeRequestDTO> dependantCustomAttributeRequestDTOS = new ArrayList<>();        for (CompanyCustomAttributeResponseDTO c : companyCustomAttributeResponseDTOS) {            dependantCustomAttributeRequestDTOS.add(filterDependantCustomAttribute(c, dependantCustomAttributeResponseDTOS, isNewHire));        }        dependantCustomAttributeRequestDTOS.removeIf(p -> p.getCustomAttributeValueNo() == null && p.getCustomAttributeValueStr() == null);        return dependantCustomAttributeRequestDTOS.stream().filter(x -> x.getCustomAttributeNo() != null).collect(Collectors.toList());    }    private DependantCustomAttributeRequestDTO filterDependantCustomAttribute(CompanyCustomAttributeResponseDTO c, List<DependantCustomAttributeResponseDTO> dependantCustomAttributeResponseDTOS, boolean isNewHire) {        DependantCustomAttributeRequestDTO dependantCustomAttributeRequestDTO = new DependantCustomAttributeRequestDTO();        Map<String, String> customAttributeMaps = new HashMap<>();        String customAttributeName = c.getCustomAttributeStr();        String customAttributeValueName = customAttributeMaps.get(customAttributeName);        DependantCustomAttributeRequestDTO ignoreDependantCustomAttributeExists = importDependantHelper.ignoreDependantCustomAttributeExists(dependantCustomAttributeResponseDTOS, customAttributeName, customAttributeValueName);        if (ignoreDependantCustomAttributeExists != null) {            return ignoreDependantCustomAttributeExists;        }        dependantCustomAttributeRequestDTO.setEffectiveDate(TimeZoneUtil.now());        dependantCustomAttributeRequestDTO.setCustomAttributeNo(c.getCustomAttributeNo());        if (isNewHire && dependantStartDate != null) {            dependantCustomAttributeRequestDTO.setEffectiveDate(dependantStartDate);        }        return dependantCustomAttributeRequestDTO;    }} 

package com.parkway.di.entity.imp.housing;import com.parkway.di.entity.ProcessingMaster;import lombok.Getter;import lombok.Setter;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import java.io.Serializable;import java.time.LocalDate;@Getter@Setter@Entity@Table(name = "HOUSING_EMPLOYEE_RAW_DATA")public class HousingEmployeeRawData extends ProcessingMaster {    @Column(name = "STAFF_ID")    private String staffId;    @Column(name = "FULL_NAME")    private String name;    @Column(name = "IDENTITY NUMBER")    private String empNricNo;    @Column(name = "GENDER")    private String gender;    @Column(name = "DATE_OF_BIRTH")    private LocalDate dob;    @Column(name = "CUSTOM_ATTRIBUTE")    private String group;    @Column(name = "MARITAL_STATUS")    private String maritalStatus;    @Column(name = "PLAN")    private String currentMedicalScheme;    @Column(name = "TERMINATION_DATE")    private LocalDate terminationDate;    @Column(name = "EMAIL")    private String emailAdress;    @Column(name = "REQUEST_ID")    private String requestId;}   package com.parkway.di.entity.imp.housing; ... by Nguyen Tran Khac Dung (FHN.HIS)Nguyen Tran Khac Dung (FHN.HIS)Yesterday 11:43 PMpackage com.parkway.di.entity.imp.housing;import com.parkway.di.entity.ProcessingSuccess;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import java.time.LocalDate;@NoArgsConstructor@AllArgsConstructor@Getter@Setter@Entity@Table(name = "HOUSING_EMPLOYEE_SUCCESS")public class HousingEmployeeSuccess extends ProcessingSuccess {    @Id    @Column(name = "RECORD_ID")    private Integer recordId;    @Column(name = "STAFF_ID")    private String staffId;    @Column(name = "FULL_NAME")    private String name;    @Column(name = "IDENTITY NUMBER")    private String empNricNo;    @Column(name = "GENDER")    private String gender;    @Column(name = "DATE_OF_BIRTH")    private LocalDate dob;    @Column(name = "CUSTOM_ATTRIBUTE")    private String group;    @Column(name = "MARITAL_STATUS")    private String maritalStatus;    @Column(name = "PLAN")    private String currentMedicalScheme;    @Column(name = "TERMINATION_DATE")    private LocalDate terminationDate;    @Column(name = "EMAIL")    private String emailAdress;    @Column(name = "REQUEST_ID")    private String requestId;}   package com.parkway.di.entity.imp.housing; ... by Nguyen Tran Khac Dung (FHN.HIS)Nguyen Tran Khac Dung (FHN.HIS)Yesterday 11:44 PMpackage com.parkway.di.entity.imp.housing;import com.parkway.di.constants.EntityConstant;import com.parkway.di.entity.ProcessingFailure;import com.parkway.di.entity.ProcessingMaster;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import javax.persistence.*;import java.time.LocalDate;@NoArgsConstructor@AllArgsConstructor@Getter@Setter@Entity@Table(name = "HOUSING_EMPLOYEE_FAILURE")public class HousingEmployeeFailure extends ProcessingFailure {    @Id    @Column(name = "RECORD_ID")    private Integer recordId;    @Column(name = "STAFF_ID")    private String staffId;    @Column(name = "FULL_NAME")    private String name;    @Column(name = "IDENTITY NUMBER")    private String empNricNo;    @Column(name = "GENDER")    private String gender;    @Column(name = "DATE_OF_BIRTH")    private LocalDate dob;    @Column(name = "CUSTOM_ATTRIBUTE")    private String group;    @Column(name = "MARITAL_STATUS")    private String maritalStatus;    @Column(name = "PLAN")    private String currentMedicalScheme;    @Column(name = "TERMINATION_DATE")    private LocalDate terminationDate;    @Column(name = "EMAIL")    private String emailAdress;    @Column(name = "REQUEST_ID")    private String requestId;}   package com.parkway.di.entity.imp.housing; ... by Nguyen Tran Khac Dung (FHN.HIS)Nguyen Tran Khac Dung (FHN.HIS)Yesterday 11:44 PMpackage com.parkway.di.entity.imp.housing;import com.parkway.di.entity.ProcessingSuccess;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import java.time.LocalDate;@NoArgsConstructor@AllArgsConstructor@Getter@Setter@Entity@Table(name = "HOUSING_DEPENDANT_SUCCESS")public class HousingDependantSuccess extends ProcessingSuccess {    @Id    @Column(name = "RECORD_ID")    private Integer recordId;    @Column(name = "STAFF_ID")    private String staffId;    @Column(name = "FULL_NAME")    private String nameOfEmployee;    @Column(name = "IDENTITY_NUMBER")    private String empNric;    @Column(name = "GENDER")    private String genderOfEmployee;    @Column(name = "DATE_OF_BIRTH")    private LocalDate dobOfDEmployee;    @Column(name = "CUSTOM_ATTRIBUTE")    private LocalDate group;    @Column(name = "PLAN")    private String currentMedicalScheme;    @Column(name = "FULL_NAME")    private String nameOfDependent;    @Column(name = "DEPENDANT_FULL_NAME")    private String depNric;    @Column(name = "DEPENDANT_DATE_OF_BIRTH")    private LocalDate dobOfDependant;    @Column(name = "DEPENDANT_GENDER")    private String genderOfDependant;    @Column(name = "RELATIONSHIP")    private String relationship;    @Column(name = "TERMINATION_DATE")    private LocalDate dateLeftService;    @Column(name = "REQUEST_ID")    private String requestId;}   package com.parkway.di.entity.imp.housing; ... by Nguyen Tran Khac Dung (FHN.HIS)Nguyen Tran Khac Dung (FHN.HIS)Yesterday 11:44 PMpackage com.parkway.di.entity.imp.housing;import com.parkway.di.entity.ProcessingMaster;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Table;import java.time.LocalDate;@NoArgsConstructor@AllArgsConstructor@Getter@Setter@Entity@Table(name = "HOUSING_DEPENDANT_RAW_DATA")public class HousingDependantRawData extends ProcessingMaster {    @Column(name = "STAFF_ID")    private String staffId;    @Column(name = "FULL_NAME")    private String nameOfEmployee;    @Column(name = "IDENTITY_NUMBER")    private String empNric;    @Column(name = "GENDER")    private String genderOfEmployee;    @Column(name = "DATE_OF_BIRTH")    private LocalDate dobOfDEmployee;    @Column(name = "CUSTOM_ATTRIBUTE")    private LocalDate group;    @Column(name = "PLAN")    private String currentMedicalScheme;    @Column(name = "FULL_NAME")    private String nameOfDependent;    @Column(name = "DEPENDANT_FULL_NAME")    private String depNric;    @Column(name = "DEPENDANT_DATE_OF_BIRTH")    private LocalDate dobOfDependant;    @Column(name = "DEPENDANT_GENDER")    private String genderOfDependant;    @Column(name = "RELATIONSHIP")    private String relationship;    @Column(name = "TERMINATION_DATE")    private LocalDate dateLeftService;    @Column(name = "REQUEST_ID")    private String requestId;}   package com.parkway.di.entity.imp.housing; 
 PMpackage com.parkway.di.entity.imp.housing;import com.parkway.di.entity.ProcessingFailure;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.Id;import javax.persistence.Table;import java.time.LocalDate;@NoArgsConstructor@AllArgsConstructor@Getter@Setter@Entity@Table(name = "HOUSING_DEPENDANT_FAILURE")public class HousingDependantFailure extends ProcessingFailure {    @Id    @Column(name = "RECORD_ID")    private Integer recordId;    @Column(name = "STAFF_ID")    private String staffId;    @Column(name = "FULL_NAME")    private String nameOfEmployee;    @Column(name = "IDENTITY_NUMBER")    private String empNric;    @Column(name = "GENDER")    private String genderOfEmployee;    @Column(name = "DATE_OF_BIRTH")    private LocalDate dobOfDEmployee;    @Column(name = "CUSTOM_ATTRIBUTE")    private LocalDate group;    @Column(name = "PLAN")    private String currentMedicalScheme;    @Column(name = "FULL_NAME")    private String nameOfDependent;    @Column(name = "DEPENDANT_FULL_NAME")    private String depNric;    @Column(name = "DEPENDANT_DATE_OF_BIRTH")    private LocalDate dobOfDependant;    @Column(name = "DEPENDANT_GENDER")    private String genderOfDependant;    @Column(name = "RELATIONSHIP")    private String relationship;    @Column(name = "TERMINATION_DATE")    private LocalDate dateLeftService;    @Column(name = "REQUEST_ID")    private String requestId;}   package com.parkway.di.entity.imp.housing; ... by Nguyen Tran Khac Dung (FHN.HIS)Nguyen Tran Khac Dung (FHN.HIS)Yesterday 11:44 PMpackage com.parkway.di.entity.imp.housing;import com.parkway.di.entity.ProcessingConfigVariable;import lombok.Getter;import lombok.Setter;import javax.persistence.Entity;import javax.persistence.Table;@Getter@Setter@Entity@Table(name = "HOUSING_CONFIG_VARIABLE")public class HousingConfigVariable extends ProcessingConfigVariable {}   package com.parkway.di.entity.imp.repo; imp... by Nguyen Tran Khac Dung (FHN.HIS)Nguyen Tran Khac Dung (FHN.HIS)Yesterday 11:45 PMpackage com.parkway.di.entity.imp.repo;import com.parkway.di.entity.imp.customRepos.ProcessingFailureRepository;import com.parkway.di.entity.imp.housing.HousingEmployeeFailure;import com.parkway.di.entity.imp.standard.StandardEmployeeSuccess;import org.springframework.data.jpa.repository.Modifying;import org.springframework.transaction.annotation.Transactional;import java.util.List;public interface HousingEmployeeFailureRepository extends ProcessingFailureRepository<HousingEmployeeFailure, Integer> {    List<HousingEmployeeFailure> findByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(String requestId);    @Modifying    @Transactional    long deleteByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(String clientId);}   package com.parkway.di.entity.imp.repo; imp... by Nguyen Tran Khac Dung (FHN.HIS)Nguyen Tran Khac Dung (FHN.HIS)Yesterday 11:45 PMpackage com.parkway.di.entity.imp.repo;import com.parkway.di.entity.imp.housing.HousingEmployeeRawData;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Modifying;import org.springframework.stereotype.Repository;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Repositorypublic interface HousingEmployeeRawDataRepository extends JpaRepository<HousingEmployeeRawData, Integer> {    List<HousingEmployeeRawData> findByRecordIdIn(List<Integer> recordIds);    List<HousingEmployeeRawData> findByRequestId(String requestId);    @Modifying    @Transactional    long deleteByRequestId(String requestId);}   package com.parkway.di.entity.imp.repo; imp... by Nguyen Tran Khac Dung (FHN.HIS)Nguyen Tran Khac Dung (FHN.HIS)Yesterday 11:45 PMpackage com.parkway.di.entity.imp.repo;import com.parkway.di.entity.imp.customRepos.ProcessingSuccessRepository;import com.parkway.di.entity.imp.housing.HousingEmployeeSuccess;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface HousingEmployeeSuccessRepository extends ProcessingSuccessRepository<HousingEmployeeSuccess, Integer> {    List<HousingEmployeeSuccess> findByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(String requestId);}   package com.parkway.di.entity.imp.repo; imp... by Nguyen Tran Khac Dung (FHN.HIS)Nguyen Tran Khac Dung (FHN.HIS)Yesterday 11:45 PMpackage com.parkway.di.entity.imp.repo;import com.parkway.di.entity.imp.customRepos.ProcessingSuccessRepository;import com.parkway.di.entity.imp.housing.HousingDependantSuccess;import java.util.List;public interface HousingDependantSuccessRepository extends ProcessingSuccessRepository<HousingDependantSuccess, Integer> {    List<HousingDependantSuccess> findByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(String requestId);}   package com.parkway.di.entity.imp.repo; imp... by Nguyen Tran Khac Dung (FHN.HIS)Nguyen Tran Khac Dung (FHN.HIS)Yesterday 11:45 PMpackage com.parkway.di.entity.imp.repo;import com.parkway.di.entity.imp.housing.HousingDependantRawData;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.Modifying;import org.springframework.stereotype.Repository;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Repositorypublic interface HousingDependantRawDataRepository extends JpaRepository<HousingDependantRawData, Integer> {    List<HousingDependantRawData> findByRecordIdIn(List<Integer> recordIds);    List<HousingDependantRawData> findByRequestId(String requestId);    @Modifying    @Transactional    long deleteByRequestId(String requestId);}   package com.parkway.di.entity.imp.repo; imp... by Nguyen Tran Khac Dung (FHN.HIS)Nguyen Tran Khac Dung (FHN.HIS)Yesterday 11:45 PMpackage com.parkway.di.entity.imp.repo;import com.parkway.di.entity.imp.customRepos.ProcessingFailureRepository;import com.parkway.di.entity.imp.housing.HousingDependantFailure;import org.springframework.data.jpa.repository.Modifying;import org.springframework.transaction.annotation.Transactional;import java.util.List;public interface HousingDependantFailureRepository extends ProcessingFailureRepository<HousingDependantFailure, Integer> {    List<HousingDependantFailure> findByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(String requestId);    @Modifying    @Transactional    long deleteByIsSentIsFalseAndRequestIdOrderByLineNumberAsc(String clientId);}   package com.parkway.di.entity.imp.repo; imp... by Nguyen Tran Khac Dung (FHN.HIS)Nguyen Tran Khac Dung (FHN.HIS)Yesterday 11:46 PMpackage com.parkway.di.entity.imp.repo;import com.parkway.di.entity.imp.customRepos.ProcessingConfigVariableRepository;import com.parkway.di.entity.imp.housing.HousingConfigVariable;import org.springframework.stereotype.Repository;@Repositorypublic interface HousingConfigVariableRepository extends ProcessingConfigVariableRepository<HousingConfigVariable, Integer> {}